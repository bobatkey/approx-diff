{-# OPTIONS --prop --postfix-projections --safe #-}

open import Level using (_âŠ”_)
open import Data.Product using (_,_)
open import prop using (_,_)
open import prop-setoid
  using (IsEquivalence; Setoid; ğŸ™; +-setoid; âŠ—-setoid; idS; _âˆ˜S_; module â‰ˆ-Reasoning)
  renaming (_â‡’_ to _â‡’s_; _â‰ƒm_ to _â‰ˆs_; â‰ƒm-isEquivalence to â‰ˆs-isEquivalence)
open import categories
  using (Category; HasExponentials; HasProducts; HasCoproducts)
open import fam
  using (HasSetoidProducts; Fam;
         _â‡’f_; _â‰ƒf_; â‰ƒf-isEquivalence;
         idf; _âˆ˜f_; âˆ˜f-cong; â‰ƒf-assoc; â‰ƒf-id-right; â‰ƒf-id-left;
         _[_]; reindex-â‰ˆ; reindex-â‰ˆ-refl; reindex-â‰ˆ-trans; reindex-comp-â‰ˆ;
         reindex-comp; constantFam; constF; reindex-f; reindex-f-cong; reindex-f-id; reindex-sq; reindex-f-comp)
open import cmon-enriched
  using (CMonEnriched; Biproduct; biproductsâ†’products; biproductsâ†’coproducts; copair-prod; inâ‚-natural; inâ‚‚-natural)
open import grothendieck using (module CategoryOfFamilies)

-- If ğ’ has binary biproducts and Setoid-indexed products, then Fam(ğ’)
-- has exponentials.
--
-- More precisely, if ğ’ has binary coproducts and Setoid-indexed
-- products, then the category of families has symmetric monoidal
-- structure (with the monoidal product generated by the
-- coproduct). If the coproducts are in fact biproducts, then Fam(ğ’)
-- is cartesian closed.

module families-exponentials {o m e} os es
   (ğ’ : Category o m e)
   (CMğ’ : CMonEnriched ğ’)
   (BP : âˆ€ x y â†’ Biproduct CMğ’ x y)
   (SP : HasSetoidProducts (m âŠ” e âŠ” os âŠ” es) (os âŠ” es âŠ” m âŠ” e) ğ’)
       where

module Famğ’ = CategoryOfFamilies (m âŠ” e âŠ” os âŠ” es) (os âŠ” es âŠ” m âŠ” e) ğ’

open Famğ’

open Obj
open Fam
open Mor
open _â‰ƒ_

open Category ğ’ renaming (_â‰ˆ_ to _â‰ˆC_)
open IsEquivalence
open HasExponentials
open HasSetoidProducts
open HasProducts
open HasCoproducts

private
  P  = biproductsâ†’products _ BP
  CP = biproductsâ†’coproducts _ BP
open products P

open Setoid
open _â‡’s_
open _â‡’f_
open _â‰ˆs_
open _â‰ƒf_

_âŸ¶_ : Obj â†’ Obj â†’ Obj
(X âŸ¶ Y) .idx = Category.hom-setoid cat X Y
(X âŸ¶ Y) .fam .fm f = SP .Î  (X .idx) (Y .fam [ f .idxf ])
(X âŸ¶ Y) .fam .subst {f} {g} e =
  Î -map SP (reindex-â‰ˆ (f .idxf) (g .idxf) (e .idxf-eq))
(X âŸ¶ Y) .fam .refl* {f} =
  isEquiv .trans (Î -map-cong SP (reindex-â‰ˆ-refl (f .idxf))) (Î -map-id SP)
(X âŸ¶ Y) .fam .trans* {f} {g} {h} gâ‰ˆh fâ‰ˆg =
  isEquiv .trans (Î -map-cong SP (reindex-â‰ˆ-trans _ _)) (Î -map-comp SP _ _)

evalâŸ¶ : âˆ€ {X Y : Obj} â†’ Mor ((X âŸ¶ Y) âŠ— X) Y
evalâŸ¶ .idxf .func (f , x) = f .idxf .func x
evalâŸ¶ .idxf .func-resp-â‰ˆ (fâ‚â‰ˆfâ‚‚ , xâ‚â‰ˆxâ‚‚) = fâ‚â‰ˆfâ‚‚ .idxf-eq .func-eq xâ‚â‰ˆxâ‚‚
evalâŸ¶ .famf .transf (f , x) =
  CP .copair (SP .evalÎ  _ x) (f .famf .transf x)
evalâŸ¶ {X} {Y} .famf .natural {fâ‚ , xâ‚} {fâ‚‚ , xâ‚‚} (fâ‚â‰ˆfâ‚‚ , xâ‚â‰ˆxâ‚‚) =
  begin
    CP .copair (SP .evalÎ  (Y .fam [ fâ‚‚ .idxf ]) xâ‚‚) (fâ‚‚ .famf .transf xâ‚‚) âˆ˜ prod-m P ((X âŸ¶ Y) .fam .subst fâ‚â‰ˆfâ‚‚) (X .fam .subst xâ‚â‰ˆxâ‚‚)
  â‰ˆâŸ¨ copair-prod _ BP âŸ©
    CP .copair (SP .evalÎ  (Y .fam [ fâ‚‚ .idxf ]) xâ‚‚ âˆ˜ (X âŸ¶ Y) .fam .subst fâ‚â‰ˆfâ‚‚) (fâ‚‚ .famf .transf xâ‚‚ âˆ˜ X .fam .subst xâ‚â‰ˆxâ‚‚)
  â‰ˆâŸ¨ CP .copair-cong (SP .lambda-eval xâ‚‚) (fâ‚‚ .famf .natural xâ‚â‰ˆxâ‚‚) âŸ©
    CP .copair (Y .fam .subst _ âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚‚) (Y .fam .subst _ âˆ˜ fâ‚‚ .famf .transf xâ‚)
  â‰ˆË˜âŸ¨ CP .copair-cong (âˆ˜-cong â‰ˆ-refl (SP .evalÎ -cong xâ‚â‰ˆxâ‚‚)) (âˆ˜-cong â‰ˆ-refl (fâ‚â‰ˆfâ‚‚ .famf-eq .transf-eq)) âŸ©
    CP .copair (Y .fam .subst _ âˆ˜ (Y .fam .subst _ âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚)) (Y .fam .subst _ âˆ˜ (Y .fam .subst _ âˆ˜ fâ‚ .famf .transf xâ‚))
  â‰ˆË˜âŸ¨ CP .copair-cong (assoc _ _ _) (assoc _ _ _) âŸ©
    CP .copair ((Y .fam .subst _ âˆ˜ Y .fam .subst _) âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚) ((Y .fam .subst _ âˆ˜ Y .fam .subst _) âˆ˜ fâ‚ .famf .transf xâ‚)
  â‰ˆË˜âŸ¨ CP .copair-cong (âˆ˜-cong (Y .fam .trans* _ _) â‰ˆ-refl) (âˆ˜-cong (Y .fam .trans* _ _) â‰ˆ-refl) âŸ©
    CP .copair (Y .fam .subst _ âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚) (Y .fam .subst _ âˆ˜ fâ‚ .famf .transf xâ‚)
  â‰ˆË˜âŸ¨ copair-natural CP _ _ _ âŸ©
    Y .fam .subst _ âˆ˜ CP .copair (SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚) (fâ‚ .famf .transf xâ‚)
  âˆ
  where open â‰ˆ-Reasoning isEquiv

nudge : âˆ€ {X Y : Setoid (m âŠ” e âŠ” os âŠ” es) (m âŠ” e âŠ” os âŠ” es)} â†’ X .Carrier â†’ Y â‡’s âŠ—-setoid X Y
nudge x .func y = x , y
nudge {X} x .func-resp-â‰ˆ e = X .refl , e

nudge-â‰ˆ : âˆ€ {X Y : Setoid (m âŠ” e âŠ” os âŠ” es) (m âŠ” e âŠ” os âŠ” es)} {xâ‚ xâ‚‚} â†’ X ._â‰ˆ_ xâ‚ xâ‚‚ â†’ nudge {X = X} {Y = Y} xâ‚ â‰ˆs nudge xâ‚‚
nudge-â‰ˆ xâ‚â‰ˆxâ‚‚ .func-eq yâ‚â‰ˆyâ‚‚ = xâ‚â‰ˆxâ‚‚ , yâ‚â‰ˆyâ‚‚

nudge-inâ‚ : âˆ€ {X Y : Obj} (x : X .idx .Carrier) â†’
            constantFam _ _ (X .fam .fm x) â‡’f ((X âŠ— Y) .fam [ nudge x ])
nudge-inâ‚ {X} {Y} x .transf y = CP .inâ‚
nudge-inâ‚ {X} {Y} x .natural e =
  begin
    CP .inâ‚ âˆ˜ id _
  â‰ˆË˜âŸ¨ âˆ˜-cong â‰ˆ-refl (X .fam .refl*) âŸ©
    CP .inâ‚ âˆ˜ X .fam .subst _
  â‰ˆË˜âŸ¨ inâ‚-natural _ BP âŸ©
    (X âŠ— Y) .fam .subst _ âˆ˜ CP .inâ‚
  âˆ
  where open â‰ˆ-Reasoning isEquiv

nudge-inâ‚‚ : âˆ€ {X Y : Obj} (x : X .idx .Carrier) â†’
            Y .fam â‡’f ((X âŠ— Y) .fam [ nudge x ])
nudge-inâ‚‚ {X} {Y} x .transf y = CP .inâ‚‚
nudge-inâ‚‚ {X} {Y} x .natural e = â‰ˆ-sym (inâ‚‚-natural _ BP)

nudge-inâ‚‚-â‰ˆ : âˆ€ {X Y : Obj} {xâ‚ xâ‚‚ : X .idx .Carrier}
              (xâ‚â‰ˆxâ‚‚ : X .idx ._â‰ˆ_ xâ‚ xâ‚‚) â†’
              (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) (nudge-â‰ˆ xâ‚â‰ˆxâ‚‚) âˆ˜f nudge-inâ‚‚ xâ‚) â‰ƒf nudge-inâ‚‚ {X = X} {Y = Y} xâ‚‚
nudge-inâ‚‚-â‰ˆ {X} {Y} xâ‚â‰ˆxâ‚‚ .transf-eq =
  begin
    (X âŠ— Y) .fam .subst _ âˆ˜ CP .inâ‚‚
  â‰ˆâŸ¨ inâ‚‚-natural _ BP âŸ©
    CP .inâ‚‚ âˆ˜ Y .fam .subst _
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (Y .fam .refl*) âŸ©
    CP .inâ‚‚ âˆ˜ id _
  â‰ˆâŸ¨ id-right âŸ©
    CP .inâ‚‚
  âˆ
  where open â‰ˆ-Reasoning isEquiv

nudge-inâ‚-â‰ˆ : âˆ€ {X Y : Obj} {xâ‚ xâ‚‚ : X .idx .Carrier}
              (xâ‚â‰ˆxâ‚‚ : X .idx ._â‰ˆ_ xâ‚ xâ‚‚) â†’
              (nudge-inâ‚ {X = X} {Y = Y} xâ‚‚ âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚)) â‰ƒf (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) (nudge-â‰ˆ xâ‚â‰ˆxâ‚‚) âˆ˜f nudge-inâ‚ xâ‚)
nudge-inâ‚-â‰ˆ {X} {Y} xâ‚â‰ˆxâ‚‚ .transf-eq = â‰ˆ-sym (inâ‚-natural _ BP)

lambdaâŸ¶ : âˆ€ {X Y Z} â†’ Mor (X âŠ— Y) Z â†’ Mor X (Y âŸ¶ Z)
lambdaâŸ¶ f .idxf .func x .idxf = f .idxf âˆ˜S nudge x
lambdaâŸ¶ f .idxf .func x .famf = reindex-comp âˆ˜f ((reindex-f (nudge x) (f .famf)) âˆ˜f nudge-inâ‚‚ x)
lambdaâŸ¶ f .idxf .func-resp-â‰ˆ xâ‚â‰ˆxâ‚‚ .idxf-eq .func-eq yâ‚â‰ˆyâ‚‚ = f .idxf .func-resp-â‰ˆ (xâ‚â‰ˆxâ‚‚ , yâ‚â‰ˆyâ‚‚)
lambdaâŸ¶ {X} {Y} {Z} f .idxf .func-resp-â‰ˆ {xâ‚} {xâ‚‚} xâ‚â‰ˆxâ‚‚ .famf-eq =
  begin
    reindex-â‰ˆ (f .idxf âˆ˜S nudge xâ‚) (f .idxf âˆ˜S nudge xâ‚‚) _ âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚))
  â‰ˆË˜âŸ¨ â‰ƒf-assoc _ _ _ âŸ©
    (reindex-â‰ˆ (f .idxf âˆ˜S nudge xâ‚) (f .idxf âˆ˜S nudge xâ‚‚) _ âˆ˜f reindex-comp) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (reindex-comp-â‰ˆ _ _ (nudge-â‰ˆ xâ‚â‰ˆxâ‚‚)) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f reindex-f (nudge xâ‚) (reindex-â‰ˆ _ _ _))) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-cong (reindex-â‰ˆ-refl _)))) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f reindex-f (nudge xâ‚) (idf _))) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-id _ _))) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f idf _)) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl â‰ƒf-id-right) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ â‰ƒf-assoc _ _ _ âŸ©
    reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚))
  â‰ˆË˜âŸ¨ âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _) âŸ©
    reindex-comp âˆ˜f ((reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆË˜âŸ¨ âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-sq _ _) â‰ƒf-refl) âŸ©
    reindex-comp âˆ˜f ((reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _) âŸ©
    reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f nudge-inâ‚‚ xâ‚))
  â‰ˆâŸ¨ âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (nudge-inâ‚‚-â‰ˆ xâ‚â‰ˆxâ‚‚)) âŸ©
    reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚‚)
  âˆ
  where open â‰ˆ-Reasoning â‰ƒf-isEquivalence
lambdaâŸ¶ {X} {Y} {Z} f .famf .transf x =
  SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge x) (f .famf) âˆ˜f nudge-inâ‚ x))
lambdaâŸ¶ {X} {Y} {Z} f .famf .natural {xâ‚} {xâ‚‚} xâ‚â‰ˆxâ‚‚ =
  begin
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚‚)) âˆ˜ X .fam .subst xâ‚â‰ˆxâ‚‚
  â‰ˆâŸ¨ lambdaÎ -natural SP _ _ âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚‚)) âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚‚) âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚)))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f (nudge-inâ‚ xâ‚‚ âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚))))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (nudge-inâ‚-â‰ˆ xâ‚â‰ˆxâ‚‚))) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f nudge-inâ‚ xâ‚)))
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f reindex-â‰ˆ _ _ _) âˆ˜f nudge-inâ‚ xâ‚))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-sq _ _) â‰ƒf-refl)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-â‰ˆ _ _ _ âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚))
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f reindex-f (nudge xâ‚) (f .famf))) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (â‰ƒf-assoc _ _ _) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f reindex-â‰ˆ _ _ _) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl â‰ƒf-id-right) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f idf _)) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-id _ (nudge xâ‚)))) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f reindex-f _ (idf _))) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-cong (reindex-â‰ˆ-refl _)))) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f reindex-f _ (reindex-â‰ˆ _ _ _))) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (reindex-comp-â‰ˆ _ _ _) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-â‰ˆ _ _ _ âˆ˜f reindex-comp) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (â‰ƒf-assoc _ _ _) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ ((reindex-â‰ˆ _ _ _ âˆ˜f (reindex-comp âˆ˜f reindex-f (nudge xâ‚) (f .famf))) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆâŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ (reindex-â‰ˆ _ _ _ âˆ˜f ((reindex-comp âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-â‰ˆ _ _ _ âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚)))
  â‰ˆâŸ¨ lambda-compose SP _ _ âŸ©
    Î -map SP (reindex-â‰ˆ _ _ _) âˆ˜ SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚))
  âˆ
  where open â‰ˆ-Reasoning isEquiv

private
  module PP = HasProducts products

lambdaâŸ¶-cong : âˆ€ {X Y Z} {fâ‚ fâ‚‚ : Mor (X âŠ— Y) Z} â†’ fâ‚ â‰ƒ fâ‚‚ â†’ lambdaâŸ¶ fâ‚ â‰ƒ lambdaâŸ¶ fâ‚‚
lambdaâŸ¶-cong fâ‚â‰ƒfâ‚‚ .idxf-eq .func-eq xâ‚â‰ˆxâ‚‚ .idxf-eq .func-eq yâ‚â‰ˆyâ‚‚ = fâ‚â‰ƒfâ‚‚ .idxf-eq .func-eq (xâ‚â‰ˆxâ‚‚ , yâ‚â‰ˆyâ‚‚)
lambdaâŸ¶-cong {X} {Y} {Z} {fâ‚} {fâ‚‚} fâ‚â‰ƒfâ‚‚ .idxf-eq .func-eq {xâ‚} {xâ‚‚} xâ‚â‰ˆxâ‚‚ .famf-eq .transf-eq {y} = begin
    Z .fam .subst _ âˆ˜ (id _ âˆ˜ (fâ‚ .famf .transf (xâ‚ , y) âˆ˜ CP .inâ‚‚))
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl id-left âŸ©
    Z .fam .subst _ âˆ˜ (fâ‚ .famf .transf (xâ‚ , y) âˆ˜ CP .inâ‚‚)
  â‰ˆË˜âŸ¨ assoc _ _ _ âŸ©
    (Z .fam .subst _ âˆ˜ fâ‚ .famf .transf (xâ‚ , y)) âˆ˜ CP .inâ‚‚
  â‰ˆâŸ¨ âˆ˜-cong (âˆ˜-cong (Z .fam .trans* (fâ‚â‰ƒfâ‚‚ .idxf-eq .func-eq (X .idx .refl , Y .idx .refl) ) (fâ‚ .idxf .func-resp-â‰ˆ (xâ‚â‰ˆxâ‚‚ , (Y .idx .refl)))) â‰ˆ-refl) â‰ˆ-refl âŸ©
    ((Z .fam .subst _ âˆ˜ Z .fam .subst _) âˆ˜ fâ‚ .famf .transf (xâ‚ , y)) âˆ˜ CP .inâ‚‚
  â‰ˆâŸ¨ âˆ˜-cong (assoc _ _ _) â‰ˆ-refl âŸ©
    (Z .fam .subst _ âˆ˜ (Z .fam .subst _ âˆ˜ fâ‚ .famf .transf (xâ‚ , y))) âˆ˜ CP .inâ‚‚
  â‰ˆâŸ¨ âˆ˜-cong (âˆ˜-cong â‰ˆ-refl (â‰ˆ-sym (fâ‚ .famf .natural (xâ‚â‰ˆxâ‚‚ , Y .idx .refl)))) â‰ˆ-refl âŸ©
    (Z .fam .subst _ âˆ˜ (fâ‚ .famf .transf (xâ‚‚ , y) âˆ˜ (X âŠ— Y) .fam .subst _)) âˆ˜ CP .inâ‚‚
  â‰ˆË˜âŸ¨ âˆ˜-cong (assoc _ _ _) â‰ˆ-refl âŸ©
    ((Z .fam .subst _ âˆ˜ fâ‚ .famf .transf (xâ‚‚ , y)) âˆ˜ (X âŠ— Y) .fam .subst _) âˆ˜ CP .inâ‚‚
  â‰ˆâŸ¨ assoc _ _ _ âŸ©
    (Z .fam .subst _ âˆ˜ fâ‚ .famf .transf (xâ‚‚ , y)) âˆ˜ ((X âŠ— Y) .fam .subst _ âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ âˆ˜-cong (fâ‚â‰ƒfâ‚‚ .famf-eq .transf-eq) (inâ‚‚-natural _ BP) âŸ©
    fâ‚‚ .famf .transf (xâ‚‚ , y) âˆ˜ (CP .inâ‚‚ âˆ˜ Y .fam .subst _)
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (âˆ˜-cong â‰ˆ-refl (Y .fam .refl*)) âŸ©
    fâ‚‚ .famf .transf (xâ‚‚ , y) âˆ˜ (CP .inâ‚‚ âˆ˜ id _)
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl id-right âŸ©
    fâ‚‚ .famf .transf (xâ‚‚ , y) âˆ˜ CP .inâ‚‚
  â‰ˆË˜âŸ¨ id-left âŸ©
    id _ âˆ˜ (fâ‚‚ .CategoryOfFamilies.Mor.famf .transf (xâ‚‚ , y) âˆ˜ CP .inâ‚‚)
  âˆ
  where open â‰ˆ-Reasoning isEquiv
lambdaâŸ¶-cong {X}{Y}{Z}{fâ‚}{fâ‚‚} fâ‚â‰ƒfâ‚‚ .famf-eq .transf-eq {x} = begin
    Î -map SP (reindex-â‰ˆ (fâ‚ .idxf âˆ˜S nudge x) (fâ‚‚ .idxf âˆ˜S nudge x) _) âˆ˜ SP .lambdaÎ  (X .fam .fm x) (Z .fam [ fâ‚ .idxf âˆ˜S nudge x ]) (reindex-comp âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x))
  â‰ˆË˜âŸ¨ lambda-compose SP _ _ âŸ©
    SP .lambdaÎ  _ _ (reindex-â‰ˆ (fâ‚ .idxf âˆ˜S nudge x) (fâ‚‚ .idxf âˆ˜S nudge x) _ âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x)))
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ ((reindex-â‰ˆ (fâ‚ .idxf âˆ˜S nudge x) (fâ‚‚ .idxf âˆ˜S nudge x) _ âˆ˜f reindex-comp) âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (reindex-comp-â‰ˆ _ _ _) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f (reindex-â‰ˆ (nudge x) (nudge x) _ âˆ˜f reindex-f (nudge x) (reindex-â‰ˆ (fâ‚ .idxf) (fâ‚‚ .idxf) (fâ‚â‰ƒfâ‚‚ .idxf-eq)))) âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-â‰ˆ-refl _) â‰ƒf-refl)) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f (idf _ âˆ˜f reindex-f (nudge x) (reindex-â‰ˆ (fâ‚ .idxf) (fâ‚‚ .idxf) (fâ‚â‰ƒfâ‚‚ .idxf-eq)))) âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl â‰ƒf-id-left) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f reindex-f (nudge x) (reindex-â‰ˆ (fâ‚ .idxf) (fâ‚‚ .idxf) (fâ‚â‰ƒfâ‚‚ .idxf-eq))) âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge x) (reindex-â‰ˆ (fâ‚ .idxf) (fâ‚‚ .idxf) (fâ‚â‰ƒfâ‚‚ .idxf-eq)) âˆ˜f (reindex-f (nudge x) (fâ‚ .famf) âˆ˜f nudge-inâ‚ x)))
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-f (nudge x) (reindex-â‰ˆ (fâ‚ .idxf) (fâ‚‚ .idxf) (fâ‚â‰ƒfâ‚‚ .idxf-eq)) âˆ˜f reindex-f (nudge x) (fâ‚ .famf)) âˆ˜f nudge-inâ‚ x))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-f-comp _ _) â‰ƒf-refl)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge x) (reindex-â‰ˆ (fâ‚ .idxf) (fâ‚‚ .idxf) (fâ‚â‰ƒfâ‚‚ .idxf-eq) âˆ˜f fâ‚ .famf) âˆ˜f nudge-inâ‚ x))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-f-cong (fâ‚â‰ƒfâ‚‚ .famf-eq)) â‰ƒf-refl)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge x) (fâ‚‚ .famf) âˆ˜f nudge-inâ‚ x))
  âˆ
  where open â‰ˆ-Reasoning isEquiv

Î²-rule : âˆ€ {X Y Z} (f : Mor (X âŠ— Y) Z) â†’
         Mor-âˆ˜ evalâŸ¶ (PP.prod-m (lambdaâŸ¶ f) (Mor-id _)) â‰ƒ f
Î²-rule f .idxf-eq .func-eq = f .idxf .func-resp-â‰ˆ
Î²-rule {X} {Y} {Z} f .famf-eq .transf-eq {x , y} =
  begin
    Z .fam .subst _ âˆ˜ (id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (id _ âˆ˜ (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚)) âˆ˜ P .pair (id _ âˆ˜ (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚)) (id _ âˆ˜ (id _ âˆ˜ P .pâ‚‚))))
  â‰ˆâŸ¨ âˆ˜-cong (Z .fam .refl*) (âˆ˜-cong â‰ˆ-refl (âˆ˜-cong (CP .copair-cong â‰ˆ-refl id-left) (P .pair-cong id-left id-left))) âŸ©
    id _ âˆ˜ (id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ P .pair (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚) (id _ âˆ˜ P .pâ‚‚)))
  â‰ˆâŸ¨ id-left âŸ©
    id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ P .pair (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚) (id _ âˆ˜ P .pâ‚‚))
  â‰ˆâŸ¨ id-left âŸ©
    CP .copair (SP .evalÎ  _ y) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ P .pair (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚) (id _ âˆ˜ P .pâ‚‚)
  â‰ˆâŸ¨ copair-prod _ BP âŸ©
    CP .copair (SP .evalÎ  _ y âˆ˜ lambdaâŸ¶ f .famf .transf x) ((f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ id _)
  â‰ˆâŸ¨ CP .copair-cong (SP .lambda-eval y) id-right âŸ©
    CP .copair (id _ âˆ˜ (f .famf .transf (x , y) âˆ˜ CP .inâ‚)) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ CP .copair-cong id-left â‰ˆ-refl âŸ©
    CP .copair (f .famf .transf (x , y) âˆ˜ CP .inâ‚) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ CP .copair-ext _ âŸ©
    f .famf .transf (x , y)
  âˆ
  where open â‰ˆ-Reasoning isEquiv

Î·-rule : âˆ€ {X Y Z} (f : Mor X (Y âŸ¶ Z)) â†’
         lambdaâŸ¶ (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y))) â‰ƒ f
Î·-rule f .idxf-eq .func-eq xâ‚â‰ˆxâ‚‚ .idxf-eq .func-eq yâ‚â‰ˆyâ‚‚ =
  f .idxf .func-resp-â‰ˆ xâ‚â‰ˆxâ‚‚ .idxf-eq .func-eq yâ‚â‰ˆyâ‚‚
Î·-rule {X} {Y} {Z} f .idxf-eq .func-eq {xâ‚} {xâ‚‚} xâ‚â‰ˆxâ‚‚ .famf-eq .transf-eq {y} =
  begin
    Z .fam .subst _ âˆ˜ (id (Z .fam .fm (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .idxf .func (xâ‚ , y))) âˆ˜ (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .famf .transf (xâ‚ , y) âˆ˜ CP .inâ‚‚))
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl id-left âŸ©
    Z .fam .subst _ âˆ˜ (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .famf .transf (xâ‚ , y) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (âˆ˜-cong id-left â‰ˆ-refl) âŸ©
    Z .fam .subst _ âˆ˜ ((CP .copair (SP .evalÎ  _ y) (f .idxf .func xâ‚ .famf .transf y) âˆ˜ PP.prod-m f (Mor-id Y) .famf .transf (xâ‚ , y)) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (âˆ˜-cong (âˆ˜-cong â‰ˆ-refl (P .pair-cong id-left id-left)) â‰ˆ-refl) âŸ©
    Z .fam .subst _ âˆ˜ ((CP .copair (SP .evalÎ  _ y) (f .idxf .func xâ‚ .famf .transf y) âˆ˜ prod-m P (f .famf .transf xâ‚) (id (Y .fam .fm y))) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (âˆ˜-cong (copair-prod _ BP) â‰ˆ-refl) âŸ©
    Z .fam .subst _ âˆ˜ (CP .copair (SP .evalÎ  _ y âˆ˜ f .famf .transf xâ‚) (f .idxf .func xâ‚ .famf .transf y âˆ˜ id (Y .fam .fm y)) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (CP .copair-inâ‚‚ _ _) âŸ©
    Z .fam .subst _ âˆ˜ (f .idxf .func xâ‚ .famf .transf y âˆ˜ id (Y .fam .fm y))
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl id-right âŸ©
    Z .fam .subst _ âˆ˜ f .idxf .func xâ‚ .famf .transf y
  â‰ˆâŸ¨ f .idxf .func-resp-â‰ˆ xâ‚â‰ˆxâ‚‚ .famf-eq .transf-eq âŸ©
    f .idxf .func xâ‚‚ .famf .transf y
  âˆ
  where open â‰ˆ-Reasoning isEquiv
Î·-rule {X} {Y} {Z} f .famf-eq .transf-eq {x} =
  let open â‰ˆ-Reasoning isEquiv in
  begin
    Î -map SP (reindex-â‰ˆ (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .idxf âˆ˜S nudge x) (f .idxf .func x .idxf) _) âˆ˜ SP .lambdaÎ  (X .fam .fm x) (Z .fam [ Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .idxf âˆ˜S nudge x ]) (reindex-comp âˆ˜f (reindex-f (nudge x) (reindex-comp âˆ˜f (reindex-f (PP.prod-m f (Mor-id Y) .idxf) (evalâŸ¶ .famf) âˆ˜f (PP.prod-m f (Mor-id Y) .famf))) âˆ˜f nudge-inâ‚ x))
  â‰ˆË˜âŸ¨ lambda-compose SP _ _ âŸ©
    SP .lambdaÎ  (X .fam .fm x) (Z .fam [ f .idxf .func x .idxf ]) (reindex-â‰ˆ (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .idxf âˆ˜S nudge x) (f .idxf .func x .idxf) _ âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge x) (reindex-comp âˆ˜f (reindex-f (PP.prod-m f (Mor-id Y) .idxf) (evalâŸ¶ .famf) âˆ˜f (PP.prod-m f (Mor-id Y) .famf))) âˆ˜f nudge-inâ‚ x)))
  â‰ˆâŸ¨ SP .lambdaÎ -cong Î·-rule-pointwise âŸ©
    SP .lambdaÎ  (X .fam .fm x) (Z .fam [ f .idxf .func x .idxf ]) (evalÎ f SP (Z .fam [ f .idxf .func x .idxf ]) âˆ˜f constF (f .famf .transf x))
  â‰ˆâŸ¨ SP .lambda-ext âŸ©
    f .famf .transf x
  âˆ
  where
  Î·-rule-pointwise : (reindex-â‰ˆ (Mor-âˆ˜ evalâŸ¶ (PP.prod-m f (Mor-id Y)) .idxf âˆ˜S nudge x) (f .idxf .func x .idxf) (record { func-eq = f .idxf .func x .idxf .func-resp-â‰ˆ }) âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge x) (reindex-comp âˆ˜f (reindex-f (PP.prod-m f (Mor-id Y) .idxf) (evalâŸ¶ .famf) âˆ˜f (PP.prod-m f (Mor-id Y) .famf))) âˆ˜f nudge-inâ‚ x)))
                     â‰ƒf (evalÎ f SP (Z .fam [ f .idxf .func x .idxf ]) âˆ˜f constF (f .famf .transf x))
  Î·-rule-pointwise .transf-eq {y} =
    begin
      fam Z .subst _ âˆ˜ (id _ âˆ˜ ((id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .idxf .func x .famf .transf y) âˆ˜ PP.prod-m f (Mor-id Y) .famf .transf (x , y))) âˆ˜ CP .inâ‚))
    â‰ˆâŸ¨ âˆ˜-cong (refl* (Z .fam)) id-left âŸ©
      id _ âˆ˜ ((id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .idxf .func x .famf .transf y) âˆ˜ PP.prod-m f (Mor-id Y) .famf .transf (x , y))) âˆ˜ CP .inâ‚)
    â‰ˆâŸ¨ id-left âŸ©
      (id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .idxf .func x .famf .transf y) âˆ˜ PP.prod-m f (Mor-id Y) .famf .transf (x , y))) âˆ˜ CP .inâ‚
    â‰ˆâŸ¨ âˆ˜-cong id-left â‰ˆ-refl âŸ©
      (CP .copair (SP .evalÎ  _ y) (f .idxf .func x .famf .transf y) âˆ˜ PP.prod-m f (Mor-id Y) .famf .transf (x , y)) âˆ˜ CP .inâ‚
    â‰ˆâŸ¨ âˆ˜-cong (âˆ˜-cong â‰ˆ-refl (P .pair-cong id-left id-left)) â‰ˆ-refl âŸ©
      (CP .copair (SP .evalÎ  _ _) (f .idxf .func x .famf .transf y) âˆ˜ prod-m P (f .famf .transf x) (Mor-id Y .famf .transf y)) âˆ˜ CP .inâ‚
    â‰ˆâŸ¨ âˆ˜-cong (copair-prod _ BP) â‰ˆ-refl âŸ©
      (CP .copair (SP .evalÎ  _ y âˆ˜ f .famf .transf x) (f .idxf .func x .famf .transf y âˆ˜ Mor-id Y .famf .transf y)) âˆ˜ CP .inâ‚
    â‰ˆâŸ¨ CP .copair-inâ‚ _ _ âŸ©
      SP .evalÎ  _ y âˆ˜ f .famf .transf x
    âˆ
    where open â‰ˆ-Reasoning isEquiv

exponentials : HasExponentials cat products
exponentials .exp = _âŸ¶_
exponentials .eval = evalâŸ¶
exponentials .lambda = lambdaâŸ¶
exponentials .lambda-cong = lambdaâŸ¶-cong
exponentials .eval-lambda = Î²-rule
exponentials .lambda-ext = Î·-rule
