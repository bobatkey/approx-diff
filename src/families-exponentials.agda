{-# OPTIONS --prop --postfix-projections --safe #-}

open import Level
open import Data.Unit using (âŠ¤; tt)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚)
open import Data.Product using (_Ã—_; projâ‚; projâ‚‚; _,_)
open import prop
open import prop-setoid
  using (IsEquivalence; Setoid; ğŸ™; +-setoid; âŠ—-setoid; idS; _âˆ˜S_; module â‰ˆ-Reasoning)
  renaming (_â‡’_ to _â‡’s_; _â‰ƒm_ to _â‰ˆs_; â‰ƒm-isEquivalence to â‰ˆs-isEquivalence)
open import categories
open import setoid-cat hiding (Î )
open import fam
open import cmon-enriched
open import grothendieck

open IsEquivalence

-- If ğ’ has binary biproducts and Setoid-indexed products, then Fam(ğ’)
-- has exponentials.
--
-- More precisely, if ğ’ has binary coproducts and Setoid-indexed
-- products, then the category of families has symmetric monoidal
-- structure (with the monoidal product generated by the
-- coproduct). If the coproducts are in fact biproducts, then Fam(ğ’)
-- is cartesian closed.

module families-exponentials {o m e} os es
   (ğ’ : Category o m e)
   (CMğ’ : CMonEnriched ğ’)
   (BP : âˆ€ x y â†’ Biproduct CMğ’ x y)
   (SP : HasSetoidProducts (m âŠ” e âŠ” os âŠ” es) (os âŠ” es âŠ” m âŠ” e) ğ’)
       where

module Famğ’ = CategoryOfFamilies (m âŠ” e âŠ” os âŠ” es) (os âŠ” es âŠ” m âŠ” e) ğ’

open Famğ’

open Obj
open Fam
open Mor
open _â‰ƒ_

open Category ğ’
open IsEquivalence
open HasExponentials
open HasSetoidProducts
open HasProducts
open HasCoproducts

private
  P  = biproductsâ†’products _ BP
  CP = biproductsâ†’coproducts _ BP
open products P

open Setoid
open _â‡’s_
open _â‡’f_
open _â‰ˆs_
open _â‰ƒf_

_âŸ¶_ : Obj â†’ Obj â†’ Obj
(X âŸ¶ Y) .idx = Category.hom-setoid cat X Y
(X âŸ¶ Y) .fam .fm f = SP .Î  (X .idx) (Y .fam [ f .idxf ])
(X âŸ¶ Y) .fam .subst {f} {g} e =
  Î -map SP (reindex-â‰ˆ (f .idxf) (g .idxf) (e .idxf-eq))
(X âŸ¶ Y) .fam .refl* {f} =
  isEquiv .trans (Î -map-cong SP (reindex-â‰ˆ-refl (f .idxf))) (Î -map-id SP)
(X âŸ¶ Y) .fam .trans* {f} {g} {h} gâ‰ˆh fâ‰ˆg =
  isEquiv .trans (Î -map-cong SP (reindex-â‰ˆ-trans _ _)) (Î -map-comp SP _ _)

evalâŸ¶ : âˆ€ {X Y : Obj} â†’ Mor ((X âŸ¶ Y) âŠ— X) Y
evalâŸ¶ .idxf .func (f , x) = f .idxf .func x
evalâŸ¶ .idxf .func-resp-â‰ˆ (fâ‚â‰ˆfâ‚‚ , xâ‚â‰ˆxâ‚‚) = fâ‚â‰ˆfâ‚‚ .idxf-eq .func-eq xâ‚â‰ˆxâ‚‚
evalâŸ¶ .famf .transf (f , x) =
  CP .copair (SP .evalÎ  _ x) (f .famf .transf x)
evalâŸ¶ {X} {Y} .famf .natural {fâ‚ , xâ‚} {fâ‚‚ , xâ‚‚} (fâ‚â‰ˆfâ‚‚ , xâ‚â‰ˆxâ‚‚) =
  begin
    CP .copair (SP .evalÎ  (Y .fam [ fâ‚‚ .idxf ]) xâ‚‚) (fâ‚‚ .famf .transf xâ‚‚) âˆ˜ prod-m P ((X âŸ¶ Y) .fam .subst fâ‚â‰ˆfâ‚‚) (X .fam .subst xâ‚â‰ˆxâ‚‚)
  â‰ˆâŸ¨ copair-prod _ BP âŸ©
    CP .copair  (SP .evalÎ  (Y .fam [ fâ‚‚ .idxf ]) xâ‚‚ âˆ˜ (X âŸ¶ Y) .fam .subst fâ‚â‰ˆfâ‚‚) (fâ‚‚ .famf .transf xâ‚‚ âˆ˜ X .fam .subst xâ‚â‰ˆxâ‚‚)
  â‰ˆâŸ¨ CP .copair-cong  (SP .lambda-eval xâ‚‚) (fâ‚‚ .famf .natural xâ‚â‰ˆxâ‚‚) âŸ©
    CP .copair (Y .fam .subst _ âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚‚) (Y .fam .subst _ âˆ˜ fâ‚‚ .famf .transf xâ‚)
  â‰ˆË˜âŸ¨ CP .copair-cong (âˆ˜-cong â‰ˆ-refl (SP .evalÎ -cong xâ‚â‰ˆxâ‚‚)) (âˆ˜-cong â‰ˆ-refl (fâ‚â‰ˆfâ‚‚ .famf-eq .transf-eq)) âŸ©
    CP .copair (Y .fam .subst _ âˆ˜ (Y .fam .subst _ âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚)) (Y .fam .subst _ âˆ˜ (Y .fam .subst _ âˆ˜ fâ‚ .famf .transf xâ‚))
  â‰ˆË˜âŸ¨ CP .copair-cong (assoc _ _ _) (assoc _ _ _) âŸ©
    CP .copair ((Y .fam .subst _ âˆ˜ Y .fam .subst _) âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚) ((Y .fam .subst _ âˆ˜ Y .fam .subst _) âˆ˜ fâ‚ .famf .transf xâ‚)
  â‰ˆË˜âŸ¨ CP .copair-cong (âˆ˜-cong (Y .fam .trans* _ _) â‰ˆ-refl) (âˆ˜-cong (Y .fam .trans* _ _) â‰ˆ-refl) âŸ©
    CP .copair (Y .fam .subst _ âˆ˜ SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚) (Y .fam .subst _ âˆ˜ fâ‚ .famf .transf xâ‚)
  â‰ˆË˜âŸ¨ copair-natural CP _ _ _ âŸ©
    Y .fam .subst _ âˆ˜ CP .copair (SP .evalÎ  (Y .fam [ fâ‚ .idxf ]) xâ‚) (fâ‚ .famf .transf xâ‚)
  âˆ
  where open â‰ˆ-Reasoning isEquiv

nudge : âˆ€ {X Y : Setoid (m âŠ” e âŠ” os âŠ” es) (m âŠ” e âŠ” os âŠ” es)} â†’ X .Carrier â†’ Y â‡’s âŠ—-setoid X Y
nudge x .func y = x , y
nudge {X} x .func-resp-â‰ˆ e = X .refl , e

nudge-â‰ˆ : âˆ€ {X Y : Setoid (m âŠ” e âŠ” os âŠ” es) (m âŠ” e âŠ” os âŠ” es)} {xâ‚ xâ‚‚} â†’ X ._â‰ˆ_ xâ‚ xâ‚‚ â†’ nudge {X = X} {Y = Y} xâ‚ â‰ˆs nudge xâ‚‚
nudge-â‰ˆ xâ‚â‰ˆxâ‚‚ .func-eq yâ‚â‰ˆyâ‚‚ = xâ‚â‰ˆxâ‚‚ , yâ‚â‰ˆyâ‚‚

nudge-inâ‚ : âˆ€ {X Y : Obj} (x : X .idx .Carrier) â†’
           constantFam _ _ (X .fam .fm x) â‡’f ((X âŠ— Y) .fam [ nudge x ])
nudge-inâ‚ {X} {Y} x .transf y = CP .inâ‚
nudge-inâ‚ {X} {Y} x .natural e =
  begin
    CP .inâ‚ âˆ˜ id _
  â‰ˆË˜âŸ¨ âˆ˜-cong â‰ˆ-refl (X .fam .refl*) âŸ©
    CP .inâ‚ âˆ˜ X .fam .subst _
  â‰ˆË˜âŸ¨ inâ‚-natural _ BP âŸ©
    (X âŠ— Y) .fam .subst _ âˆ˜ CP .inâ‚
  âˆ
  where open â‰ˆ-Reasoning isEquiv

nudge-inâ‚‚ : âˆ€ {X Y : Obj} (x : X .idx .Carrier) â†’
            Y .fam â‡’f ((X âŠ— Y) .fam [ nudge x ])
nudge-inâ‚‚ {X} {Y} x .transf y = CP .inâ‚‚
nudge-inâ‚‚ {X} {Y} x .natural e = â‰ˆ-sym (inâ‚‚-natural _ BP)

nudge-inâ‚‚-â‰ˆ : âˆ€ {X Y : Obj} {xâ‚ xâ‚‚ : X .idx .Carrier}
              (xâ‚â‰ˆxâ‚‚ : X .idx ._â‰ˆ_ xâ‚ xâ‚‚) â†’
              (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) (nudge-â‰ˆ xâ‚â‰ˆxâ‚‚) âˆ˜f nudge-inâ‚‚ xâ‚) â‰ƒf nudge-inâ‚‚ {X = X} {Y = Y} xâ‚‚
nudge-inâ‚‚-â‰ˆ {X} {Y} xâ‚â‰ˆxâ‚‚ .transf-eq =
  begin
    (X âŠ— Y) .fam .subst _ âˆ˜ CP .inâ‚‚
  â‰ˆâŸ¨ inâ‚‚-natural _ BP âŸ©
    CP .inâ‚‚ âˆ˜ Y .fam .subst _
  â‰ˆâŸ¨ âˆ˜-cong â‰ˆ-refl (Y .fam .refl*) âŸ©
    CP .inâ‚‚ âˆ˜ id _
  â‰ˆâŸ¨ id-right âŸ©
    CP .inâ‚‚
  âˆ
  where open â‰ˆ-Reasoning isEquiv

nudge-inâ‚-â‰ˆ : âˆ€ {X Y : Obj} {xâ‚ xâ‚‚ : X .idx .Carrier}
              (xâ‚â‰ˆxâ‚‚ : X .idx ._â‰ˆ_ xâ‚ xâ‚‚) â†’
              (nudge-inâ‚ {X = X} {Y = Y} xâ‚‚ âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚)) â‰ƒf (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) (nudge-â‰ˆ xâ‚â‰ˆxâ‚‚) âˆ˜f nudge-inâ‚ xâ‚)
nudge-inâ‚-â‰ˆ {X} {Y} xâ‚â‰ˆxâ‚‚ .transf-eq = â‰ˆ-sym (inâ‚-natural _ BP)

lambdaâŸ¶ : âˆ€ {X Y Z} â†’ Mor (X âŠ— Y) Z â†’ Mor X (Y âŸ¶ Z)
lambdaâŸ¶ f .idxf .func x .idxf = f .idxf âˆ˜S nudge x
lambdaâŸ¶ f .idxf .func x .famf = reindex-comp âˆ˜f ((reindex-f (nudge x) (f .famf)) âˆ˜f nudge-inâ‚‚ x)
lambdaâŸ¶ f .idxf .func-resp-â‰ˆ xâ‚â‰ˆxâ‚‚ .idxf-eq .func-eq yâ‚â‰ˆyâ‚‚ = f .idxf .func-resp-â‰ˆ (xâ‚â‰ˆxâ‚‚ , yâ‚â‰ˆyâ‚‚)
lambdaâŸ¶ {X} {Y} {Z} f .idxf .func-resp-â‰ˆ {xâ‚} {xâ‚‚} xâ‚â‰ˆxâ‚‚ .famf-eq =
  begin
    reindex-â‰ˆ (f .idxf âˆ˜S nudge xâ‚) (f .idxf âˆ˜S nudge xâ‚‚) _ âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚))
  â‰ˆË˜âŸ¨ â‰ƒf-assoc _ _ _ âŸ©
    (reindex-â‰ˆ (f .idxf âˆ˜S nudge xâ‚) (f .idxf âˆ˜S nudge xâ‚‚) _ âˆ˜f reindex-comp) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (reindex-comp-â‰ˆ _ _ (nudge-â‰ˆ xâ‚â‰ˆxâ‚‚)) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f reindex-f (nudge xâ‚) (reindex-â‰ˆ _ _ _))) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-cong (reindex-â‰ˆ-refl _)))) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f reindex-f (nudge xâ‚) (idf _))) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-id _ _))) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f idf _)) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl â‰ƒf-id-right) â‰ƒf-refl âŸ©
    (reindex-comp âˆ˜f reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _) âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ â‰ƒf-assoc _ _ _ âŸ©
    reindex-comp âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚))
  â‰ˆË˜âŸ¨ âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _) âŸ©
    reindex-comp âˆ˜f ((reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆË˜âŸ¨ âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-sq _ _) â‰ƒf-refl) âŸ©
    reindex-comp âˆ˜f ((reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _) âˆ˜f nudge-inâ‚‚ xâ‚)
  â‰ˆâŸ¨ âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _) âŸ©
    reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f (reindex-â‰ˆ (nudge xâ‚) (nudge xâ‚‚) _ âˆ˜f nudge-inâ‚‚ xâ‚))
  â‰ˆâŸ¨ âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (nudge-inâ‚‚-â‰ˆ xâ‚â‰ˆxâ‚‚)) âŸ©
    reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚‚ xâ‚‚)
  âˆ
  where open â‰ˆ-Reasoning â‰ƒf-isEquivalence
lambdaâŸ¶ {X} {Y} {Z} f .famf .transf x =
  SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge x) (f .famf) âˆ˜f nudge-inâ‚ x))
lambdaâŸ¶ {X} {Y} {Z} f .famf .natural {xâ‚} {xâ‚‚} xâ‚â‰ˆxâ‚‚ =
  begin
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚‚)) âˆ˜ X .fam .subst xâ‚â‰ˆxâ‚‚
  â‰ˆâŸ¨ lambdaÎ -natural SP _ _ âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚‚)) âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚‚) âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚)))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f (nudge-inâ‚ xâ‚‚ âˆ˜f constF (X .fam .subst xâ‚â‰ˆxâ‚‚))))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (nudge-inâ‚-â‰ˆ xâ‚â‰ˆxâ‚‚))) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f nudge-inâ‚ xâ‚)))
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-f (nudge xâ‚‚) (f .famf) âˆ˜f reindex-â‰ˆ _ _ _) âˆ˜f nudge-inâ‚ xâ‚))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong (reindex-sq _ _) â‰ƒf-refl)) âŸ©
    SP .lambdaÎ  _ _ (reindex-comp âˆ˜f ((reindex-â‰ˆ _ _ _ âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚))
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ ((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f reindex-f (nudge xâ‚) (f .famf))) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (â‰ƒf-assoc _ _ _) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f reindex-â‰ˆ _ _ _) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl â‰ƒf-id-right) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f idf _)) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-id _ (nudge xâ‚)))) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f reindex-f _ (idf _))) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (âˆ˜f-cong â‰ƒf-refl (âˆ˜f-cong â‰ƒf-refl (reindex-f-cong (reindex-â‰ˆ-refl _)))) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-comp âˆ˜f (reindex-â‰ˆ _ _ _ âˆ˜f reindex-f _ (reindex-â‰ˆ _ _ _))) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆË˜âŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (âˆ˜f-cong (reindex-comp-â‰ˆ _ _ _) â‰ƒf-refl) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ (((reindex-â‰ˆ _ _ _ âˆ˜f reindex-comp) âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong (â‰ƒf-assoc _ _ _) â‰ƒf-refl) âŸ©
    SP .lambdaÎ  _ _ ((reindex-â‰ˆ _ _ _ âˆ˜f (reindex-comp âˆ˜f reindex-f (nudge xâ‚) (f .famf))) âˆ˜f nudge-inâ‚ xâ‚)
  â‰ˆâŸ¨ SP .lambdaÎ -cong (â‰ƒf-assoc _ _ _) âŸ©
    SP .lambdaÎ  _ _ (reindex-â‰ˆ _ _ _ âˆ˜f ((reindex-comp âˆ˜f reindex-f (nudge xâ‚) (f .famf)) âˆ˜f nudge-inâ‚ xâ‚))
  â‰ˆâŸ¨ SP .lambdaÎ -cong (âˆ˜f-cong â‰ƒf-refl (â‰ƒf-assoc _ _ _)) âŸ©
    SP .lambdaÎ  _ _ (reindex-â‰ˆ _ _ _ âˆ˜f (reindex-comp âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚)))
  â‰ˆâŸ¨ lambda-compose SP _ _ âŸ©
    Î -map SP (reindex-â‰ˆ _ _ _) âˆ˜ SP .lambdaÎ  _ _ (reindex-comp âˆ˜f (reindex-f (nudge xâ‚) (f .famf) âˆ˜f nudge-inâ‚ xâ‚))
  âˆ
  where open â‰ˆ-Reasoning isEquiv

private module PP = HasProducts products

Î²-rule : âˆ€ {X Y Z} (f : Mor (X âŠ— Y) Z) â†’
         Mor-âˆ˜ evalâŸ¶ (PP.pair (Mor-âˆ˜ (lambdaâŸ¶ f) PP.pâ‚) (PP.pâ‚‚)) â‰ƒ f
Î²-rule f .idxf-eq .func-eq = f .idxf .func-resp-â‰ˆ
Î²-rule {X} {Y} {Z} f .famf-eq .transf-eq {x , y} =
  begin
    Z .fam .subst _ âˆ˜ (id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (id _ âˆ˜ (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚)) âˆ˜ P .pair (id _ âˆ˜ (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚)) (P .pâ‚‚)))
  â‰ˆâŸ¨ âˆ˜-cong (Z .fam .refl*) (âˆ˜-cong â‰ˆ-refl (âˆ˜-cong (CP .copair-cong â‰ˆ-refl id-left) (P .pair-cong id-left (â‰ˆ-sym id-left)))) âŸ©
    id _ âˆ˜ (id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ P .pair (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚) (id _ âˆ˜ P .pâ‚‚)))
  â‰ˆâŸ¨ id-left âŸ©
    id _ âˆ˜ (CP .copair (SP .evalÎ  _ y) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ P .pair (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚) (id _ âˆ˜ P .pâ‚‚))
  â‰ˆâŸ¨ id-left âŸ©
    CP .copair (SP .evalÎ  _ y) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ P .pair (lambdaâŸ¶ f .famf .transf x âˆ˜ P .pâ‚) (id _ âˆ˜ P .pâ‚‚)
  â‰ˆâŸ¨ copair-prod _ BP âŸ©
    CP .copair (SP .evalÎ  _ y âˆ˜ lambdaâŸ¶ f .famf .transf x) ((f .famf .transf (x , y) âˆ˜ CP .inâ‚‚) âˆ˜ id _)
  â‰ˆâŸ¨ CP .copair-cong (SP .lambda-eval y) id-right âŸ©
    CP .copair (id _ âˆ˜ (f .famf .transf (x , y) âˆ˜ CP .inâ‚)) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ CP .copair-cong id-left â‰ˆ-refl âŸ©
    CP .copair (f .famf .transf (x , y) âˆ˜ CP .inâ‚) (f .famf .transf (x , y) âˆ˜ CP .inâ‚‚)
  â‰ˆâŸ¨ CP .copair-ext _ âŸ©
    f .famf .transf (x , y)
  âˆ
  where open â‰ˆ-Reasoning isEquiv

lambda-invâŸ¶ : âˆ€ {X Y Z} â†’ Mor X (Y âŸ¶ Z) â†’ Mor (X âŠ— Y) Z
lambda-invâŸ¶ f .idxf .func (x , y) = f .idxf .func x .idxf .func y
lambda-invâŸ¶ f .idxf .func-resp-â‰ˆ (xâ‚â‰ˆxâ‚‚ , yâ‚â‰ˆyâ‚‚) = f .idxf .func-resp-â‰ˆ xâ‚â‰ˆxâ‚‚ .idxf-eq .func-eq yâ‚â‰ˆyâ‚‚
lambda-invâŸ¶ f .famf .transf (x , y) = let q = f .famf .transf x in {!   !}
lambda-invâŸ¶ f .famf .natural = {!   !}

exponentials : HasExponentials cat products
exponentials .exp = _âŸ¶_
exponentials .eval = evalâŸ¶
exponentials .lambda = lambdaâŸ¶
