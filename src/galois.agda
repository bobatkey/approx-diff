{-# OPTIONS --postfix-projections --prop --safe #-}

module galois where

open import Level
open import Data.Product using (_,_; proj‚ÇÅ; proj‚ÇÇ)
open import prop
open import basics
open import prop-setoid
  using (IsEquivalence)
  renaming (_‚áí_ to _‚áís_)
open import preorder
  hiding (ùüô)
open import categories
open import meet-semilattice
  using (MeetSemilattice)
  renaming (_=>_ to _=>M_; _‚âÉm_ to _‚âÉM_; id to idM; _‚àò_ to _‚àòM_;
            _‚äï_ to _‚äïM_;
            ‚âÉm-isEquivalence to ‚âÉM-isEquivalence)
open import join-semilattice
  using (JoinSemilattice)
  renaming (_=>_ to _=>J_; _‚âÉm_ to _‚âÉJ_; id to idJ; _‚àò_ to _‚àòJ_;
            _‚äï_ to _‚äïJ_;
            ‚âÉm-isEquivalence to ‚âÉJ-isEquivalence)
open import cmon-enriched

-- The category of bounded lattices and Galois connections between
-- them.
--
-- We define the objects as being partially ordered sets that have a
-- meet structure and a join structure. The morphisms are pairs of
-- adjoint monotone functions.
--
-- Fam(Galois) is our basic setting for approximation. Objects are
-- sets indexing bounded lattices of approximations. Morphisms are
-- functions between the sets, equipped with a forward derivative and
-- a reverse derivative.

record Obj : Set (suc 0‚Ñì) where
  no-eta-equality
  field
    carrier : Preorder
    meets   : MeetSemilattice carrier
    joins   : JoinSemilattice carrier
  open Preorder carrier public
open Obj

record _‚áíg_ (X Y : Obj) : Set where
  no-eta-equality
  private
    module X = Obj X
    module Y = Obj Y
  field
    -- FIXME: might be better to call these right and left
    fwd : X .meets =>M Y .meets
    bwd : Y .joins =>J X .joins
    bwd‚ä£fwd : ‚àÄ {x y} ‚Üí y Y.‚â§ (fwd ._=>M_.func x) ‚áî (bwd ._=>J_.func y) X.‚â§ x

  -- FIXME: preservation of meets and joins comes for free! Make a
  -- helper constructor.
open _‚áíg_

record _‚áíg'_ (X Y : Obj) : Set where
  no-eta-equality
  open preorder._=>_
  private
    module X = Obj X
    module Y = Obj Y
  field
    right : X .carrier preorder.=> Y .carrier
    left : Y .carrier preorder.=> X .carrier
    left‚ä£right : ‚àÄ {x y} ‚Üí y Y.‚â§ (right .func x) ‚áî (left .func y) X.‚â§ x

open _‚áíg'_

record _‚âÉg_ {X Y : Obj} (f g : X ‚áíg Y) : Prop where
  field
    fwd-eq : f .fwd ‚âÉM g .fwd
    bwd-eq : f .bwd ‚âÉJ g .bwd
open _‚âÉg_

record _‚âÉg'_ {X Y : Obj} (f g : X ‚áíg' Y) : Prop where
  field
    right-eq : f .right ‚âÉm g .right
    left-eq : f .left ‚âÉm g .left
open _‚âÉg'_

open IsEquivalence
open preorder using (‚âÉm-isEquivalence)

‚âÉg-isEquivalence : ‚àÄ {X Y} ‚Üí IsEquivalence (_‚âÉg_ {X} {Y})
‚âÉg-isEquivalence .refl .fwd-eq = ‚âÉM-isEquivalence .refl
‚âÉg-isEquivalence .refl .bwd-eq = ‚âÉJ-isEquivalence .refl
‚âÉg-isEquivalence .sym e .fwd-eq = ‚âÉM-isEquivalence .sym (e .fwd-eq)
‚âÉg-isEquivalence .sym e .bwd-eq = ‚âÉJ-isEquivalence .sym (e .bwd-eq)
‚âÉg-isEquivalence .trans e‚ÇÅ e‚ÇÇ .fwd-eq = ‚âÉM-isEquivalence .trans (e‚ÇÅ .fwd-eq) (e‚ÇÇ .fwd-eq)
‚âÉg-isEquivalence .trans e‚ÇÅ e‚ÇÇ .bwd-eq = ‚âÉJ-isEquivalence .trans (e‚ÇÅ .bwd-eq) (e‚ÇÇ .bwd-eq)

‚âÉg'-isEquivalence : ‚àÄ {X Y} ‚Üí IsEquivalence (_‚âÉg'_ {X} {Y})
‚âÉg'-isEquivalence .refl .right-eq = ‚âÉm-isEquivalence .refl
‚âÉg'-isEquivalence .refl .left-eq = ‚âÉm-isEquivalence .refl
‚âÉg'-isEquivalence .sym e .right-eq = ‚âÉm-isEquivalence .sym (e .right-eq)
‚âÉg'-isEquivalence .sym e .left-eq = ‚âÉm-isEquivalence .sym (e .left-eq)
‚âÉg'-isEquivalence .trans e‚ÇÅ e‚ÇÇ .right-eq = ‚âÉm-isEquivalence .trans (e‚ÇÅ .right-eq) (e‚ÇÇ .right-eq)
‚âÉg'-isEquivalence .trans e‚ÇÅ e‚ÇÇ .left-eq = ‚âÉm-isEquivalence .trans (e‚ÇÅ .left-eq) (e‚ÇÇ .left-eq)

idg : (X : Obj) ‚Üí X ‚áíg X
idg X .fwd = idM
idg X .bwd = idJ
idg X .bwd‚ä£fwd = refl-‚áî

idg' : (X : Obj) ‚Üí X ‚áíg' X
idg' X .right = id
idg' X .left = id
idg' X .left‚ä£right = refl-‚áî

_‚àòg_ : ‚àÄ {X Y Z : Obj} ‚Üí Y ‚áíg Z ‚Üí X ‚áíg Y ‚Üí X ‚áíg Z
(f ‚àòg g) .fwd = f .fwd ‚àòM g .fwd
(f ‚àòg g) .bwd = g .bwd ‚àòJ f .bwd
(f ‚àòg g) .bwd‚ä£fwd = trans-‚áî (f .bwd‚ä£fwd) (g .bwd‚ä£fwd)

_‚àòg'_ : ‚àÄ {X Y Z : Obj} ‚Üí Y ‚áíg' Z ‚Üí X ‚áíg' Y ‚Üí X ‚áíg' Z
(f ‚àòg' g) .right = f .right ‚àò g .right
(f ‚àòg' g) .left = g .left ‚àò f .left
(f ‚àòg' g) .left‚ä£right = trans-‚áî (f .left‚ä£right) (g .left‚ä£right)

‚àòg-cong : ‚àÄ {X Y Z}{f‚ÇÅ f‚ÇÇ : Y ‚áíg Z}{g‚ÇÅ g‚ÇÇ : X ‚áíg Y} ‚Üí f‚ÇÅ ‚âÉg f‚ÇÇ ‚Üí g‚ÇÅ ‚âÉg g‚ÇÇ ‚Üí (f‚ÇÅ ‚àòg g‚ÇÅ) ‚âÉg (f‚ÇÇ ‚àòg g‚ÇÇ)
‚àòg-cong f‚ÇÅ‚âàf‚ÇÇ g‚ÇÅ‚âàg‚ÇÇ .fwd-eq = meet-semilattice.‚àò-cong (f‚ÇÅ‚âàf‚ÇÇ .fwd-eq) (g‚ÇÅ‚âàg‚ÇÇ .fwd-eq)
‚àòg-cong f‚ÇÅ‚âàf‚ÇÇ g‚ÇÅ‚âàg‚ÇÇ .bwd-eq = join-semilattice.‚àò-cong (g‚ÇÅ‚âàg‚ÇÇ .bwd-eq) (f‚ÇÅ‚âàf‚ÇÇ .bwd-eq)

‚àòg'-cong : ‚àÄ {X Y Z}{f‚ÇÅ f‚ÇÇ : Y ‚áíg' Z}{g‚ÇÅ g‚ÇÇ : X ‚áíg' Y} ‚Üí f‚ÇÅ ‚âÉg' f‚ÇÇ ‚Üí g‚ÇÅ ‚âÉg' g‚ÇÇ ‚Üí (f‚ÇÅ ‚àòg' g‚ÇÅ) ‚âÉg' (f‚ÇÇ ‚àòg' g‚ÇÇ)
‚àòg'-cong f‚ÇÅ‚âàf‚ÇÇ g‚ÇÅ‚âàg‚ÇÇ .right-eq = ‚àò-cong (f‚ÇÅ‚âàf‚ÇÇ .right-eq) (g‚ÇÅ‚âàg‚ÇÇ .right-eq)
‚àòg'-cong f‚ÇÅ‚âàf‚ÇÇ g‚ÇÅ‚âàg‚ÇÇ .left-eq = ‚àò-cong (g‚ÇÅ‚âàg‚ÇÇ .left-eq) (f‚ÇÅ‚âàf‚ÇÇ .left-eq)

cat : Category (suc 0‚Ñì) 0‚Ñì 0‚Ñì
cat .Category.obj = Obj
cat .Category._‚áí_ = _‚áíg_
cat .Category._‚âà_ = _‚âÉg_
cat .Category.isEquiv = ‚âÉg-isEquivalence
cat .Category.id = idg
cat .Category._‚àò_ = _‚àòg_
cat .Category.‚àò-cong = ‚àòg-cong
cat .Category.id-left .fwd-eq = meet-semilattice.id-left
cat .Category.id-left .bwd-eq = join-semilattice.id-right
cat .Category.id-right .fwd-eq = meet-semilattice.id-right
cat .Category.id-right .bwd-eq = join-semilattice.id-left
cat .Category.assoc f g h .fwd-eq = meet-semilattice.assoc (f .fwd) (g .fwd) (h .fwd)
cat .Category.assoc f g h .bwd-eq =
  ‚âÉJ-isEquivalence .sym (join-semilattice.assoc (h .bwd) (g .bwd) (f .bwd))

cat' : Category (suc 0‚Ñì) 0‚Ñì 0‚Ñì
cat' .Category.obj = Obj
cat' .Category._‚áí_ = _‚áíg'_
cat' .Category._‚âà_ = _‚âÉg'_
cat' .Category.isEquiv = ‚âÉg'-isEquivalence
cat' .Category.id = idg'
cat' .Category._‚àò_ = _‚àòg'_
cat' .Category.‚àò-cong = ‚àòg'-cong
cat' .Category.id-left .right-eq = id-left
cat' .Category.id-left .left-eq = id-right
cat' .Category.id-right .right-eq = id-right
cat' .Category.id-right .left-eq = id-left
cat' .Category.assoc f g h .right-eq = assoc (f .right) (g .right) (h .right)
cat' .Category.assoc f g h .left-eq =
  ‚âÉm-isEquivalence .sym (assoc (h .left) (g .left) (f .left))

------------------------------------------------------------------------------
-- CMon enrichment
module _ {X Y : Obj} where
  open preorder._=>_

  private
    module YM = MeetSemilattice (Y .meets)
    module XJ = JoinSemilattice (X .joins)

  Œµm : X ‚áíg Y
  Œµm .fwd = meet-semilattice.Œµm
  Œµm .bwd = join-semilattice.Œµm
  Œµm .bwd‚ä£fwd .proj‚ÇÅ _ = XJ.‚â§-bottom
  Œµm .bwd‚ä£fwd .proj‚ÇÇ _ = YM.‚â§-top

  Œµm' : X ‚áíg' Y
  Œµm' .right .func x = YM.‚ä§
  Œµm' .right .mono _ = Y .‚â§-refl
  Œµm' .left .func x = XJ.‚ä•
  Œµm' .left .mono x = X .‚â§-refl
  Œµm' .left‚ä£right .proj‚ÇÅ _ = XJ.‚â§-bottom
  Œµm' .left‚ä£right .proj‚ÇÇ _ = YM.‚â§-top

  _+m_ : X ‚áíg Y ‚Üí X ‚áíg Y ‚Üí X ‚áíg Y
  (f +m g) .fwd = meet-semilattice._+m_ (f .fwd) (g .fwd)
  (f +m g) .bwd = join-semilattice._+m_ (f .bwd) (g .bwd)
  (f +m g) .bwd‚ä£fwd {x} {y} .proj‚ÇÅ y‚â§fx‚àßgx =
    XJ.[ f .bwd‚ä£fwd .proj‚ÇÅ (Y .‚â§-trans y‚â§fx‚àßgx YM.œÄ‚ÇÅ)
       ‚à® g .bwd‚ä£fwd .proj‚ÇÅ (Y .‚â§-trans y‚â§fx‚àßgx YM.œÄ‚ÇÇ)
       ]
  (f +m g) .bwd‚ä£fwd {x} {y} .proj‚ÇÇ fy‚à®gy‚â§x =
    YM.‚ü® f .bwd‚ä£fwd .proj‚ÇÇ (X .‚â§-trans XJ.inl fy‚à®gy‚â§x)
       ‚àß g .bwd‚ä£fwd .proj‚ÇÇ (X .‚â§-trans XJ.inr fy‚à®gy‚â§x)
       ‚ü©

  _+m'_ : X ‚áíg' Y ‚Üí X ‚áíg' Y ‚Üí X ‚áíg' Y
  (f +m' g) .right .func x = {!   !}
  (f +m' g) .right .mono _ = {!   !}
  (f +m' g) .left = {!   !}
  (f +m' g) .left‚ä£right {x} {y} .proj‚ÇÅ y‚â§fx‚àßgx = {!   !}

  +m-cong : ‚àÄ {f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : X ‚áíg Y} ‚Üí f‚ÇÅ ‚âÉg f‚ÇÇ ‚Üí g‚ÇÅ ‚âÉg g‚ÇÇ ‚Üí (f‚ÇÅ +m g‚ÇÅ) ‚âÉg (f‚ÇÇ +m g‚ÇÇ)
  +m-cong f‚ÇÅ‚âÉf‚ÇÇ g‚ÇÅ‚âÉg‚ÇÇ .fwd-eq = meet-semilattice.+m-cong (f‚ÇÅ‚âÉf‚ÇÇ .fwd-eq) (g‚ÇÅ‚âÉg‚ÇÇ .fwd-eq)
  +m-cong f‚ÇÅ‚âÉf‚ÇÇ g‚ÇÅ‚âÉg‚ÇÇ .bwd-eq = join-semilattice.+m-cong (f‚ÇÅ‚âÉf‚ÇÇ .bwd-eq) (g‚ÇÅ‚âÉg‚ÇÇ .bwd-eq)

  +m-comm : ‚àÄ {f g} ‚Üí (f +m g) ‚âÉg (g +m f)
  +m-comm {f} {g} .fwd-eq = meet-semilattice.+m-comm {f = f .fwd} {g = g .fwd}
  +m-comm {f} {g} .bwd-eq = join-semilattice.+m-comm {f = f .bwd} {g = g .bwd}

  +m-assoc : ‚àÄ {f g h} ‚Üí ((f +m g) +m h) ‚âÉg (f +m (g +m h))
  +m-assoc {f} {g} {h} .fwd-eq = meet-semilattice.+m-assoc {f = f .fwd} {g .fwd} {h .fwd}
  +m-assoc {f} {g} {h} .bwd-eq = join-semilattice.+m-assoc {f = f .bwd} {g .bwd} {h .bwd}

  +m-lunit : ‚àÄ {f} ‚Üí (Œµm +m f) ‚âÉg f
  +m-lunit {f} .fwd-eq = meet-semilattice.+m-lunit {f = f .fwd}
  +m-lunit {f} .bwd-eq = join-semilattice.+m-lunit {f = f .bwd}

module _ where

  open import commutative-monoid

  open CommutativeMonoid

  cmon-enriched : CMonEnriched cat
  cmon-enriched .CMonEnriched.homCM X Y .Œµ = Œµm
  cmon-enriched .CMonEnriched.homCM X Y ._+_ = _+m_
  cmon-enriched .CMonEnriched.homCM X Y .+-cong = +m-cong
  cmon-enriched .CMonEnriched.homCM X Y .+-lunit = +m-lunit
  cmon-enriched .CMonEnriched.homCM X Y .+-assoc = +m-assoc
  cmon-enriched .CMonEnriched.homCM X Y .+-comm = +m-comm
  cmon-enriched .CMonEnriched.comp-bilinear‚ÇÅ f‚ÇÅ f‚ÇÇ g .fwd-eq =
    meet-semilattice.comp-bilinear‚ÇÅ (f‚ÇÅ .fwd) (f‚ÇÇ .fwd) (g .fwd)
  cmon-enriched .CMonEnriched.comp-bilinear‚ÇÅ f‚ÇÅ f‚ÇÇ g .bwd-eq =
    join-semilattice.comp-bilinear‚ÇÇ (g .bwd) (f‚ÇÅ .bwd) (f‚ÇÇ .bwd)
  cmon-enriched .CMonEnriched.comp-bilinear‚ÇÇ f g‚ÇÅ g‚ÇÇ .fwd-eq =
    meet-semilattice.comp-bilinear‚ÇÇ (f .fwd) (g‚ÇÅ .fwd) (g‚ÇÇ .fwd)
  cmon-enriched .CMonEnriched.comp-bilinear‚ÇÇ f g‚ÇÅ g‚ÇÇ .bwd-eq =
    join-semilattice.comp-bilinear‚ÇÅ (g‚ÇÅ .bwd) (g‚ÇÇ .bwd) (f .bwd)
  cmon-enriched .CMonEnriched.comp-bilinear-Œµ‚ÇÅ f .fwd-eq =
    meet-semilattice.comp-bilinear-Œµ‚ÇÅ (f .fwd)
  cmon-enriched .CMonEnriched.comp-bilinear-Œµ‚ÇÅ f .bwd-eq =
    join-semilattice.comp-bilinear-Œµ‚ÇÇ (f .bwd)
  cmon-enriched .CMonEnriched.comp-bilinear-Œµ‚ÇÇ f .fwd-eq =
    meet-semilattice.comp-bilinear-Œµ‚ÇÇ (f .fwd)
  cmon-enriched .CMonEnriched.comp-bilinear-Œµ‚ÇÇ f .bwd-eq =
    join-semilattice.comp-bilinear-Œµ‚ÇÅ (f .bwd)

------------------------------------------------------------------------------
-- Terminal (FIXME: and initial)
module _ where
  open HasTerminal

  ùüô : Obj
  ùüô .carrier = preorder.ùüô
  ùüô .meets = meet-semilattice.ùüô
  ùüô .joins = join-semilattice.ùüô

  to-ùüô : ‚àÄ X ‚Üí X ‚áíg ùüô
  to-ùüô X .fwd = meet-semilattice.terminal
  to-ùüô X .bwd = join-semilattice.initial
  to-ùüô X .bwd‚ä£fwd .proj‚ÇÅ tt =
    X .joins .JoinSemilattice.‚ä•-isBottom .IsBottom.‚â§-bottom
  to-ùüô X .bwd‚ä£fwd .proj‚ÇÇ _ = tt

  terminal : HasTerminal cat
  terminal .witness = ùüô
  terminal .terminal-mor = to-ùüô
  terminal .terminal-unique X f g .fwd-eq = meet-semilattice.terminal-unique _ _ _
  terminal .terminal-unique X f g .bwd-eq = join-semilattice.initial-unique _ _ _

-- This category has binary products (FIXME: and biproducts)
module _ where

  open HasProducts

  -- FIXME: this is misnamed: should be _‚äï_
  _‚äó_ : Obj ‚Üí Obj ‚Üí Obj
  (X ‚äó Y) .carrier = X .carrier √ó Y .carrier
  (X ‚äó Y) .meets = X .meets ‚äïM Y .meets
  (X ‚äó Y) .joins = X .joins ‚äïJ Y .joins

  open JoinSemilattice

  products : HasProducts cat
  products .prod = _‚äó_
  products .p‚ÇÅ .fwd = meet-semilattice.project‚ÇÅ
  products .p‚ÇÅ .bwd = join-semilattice.inject‚ÇÅ
  products .p‚ÇÅ {X} {Y} .bwd‚ä£fwd {x , y} {x'} .proj‚ÇÅ x'‚â§x .proj‚ÇÅ = x'‚â§x
  products .p‚ÇÅ {X} {Y} .bwd‚ä£fwd {x , y} {x'} .proj‚ÇÅ x'‚â§x .proj‚ÇÇ = Y.‚â§-bottom
    where module Y = JoinSemilattice (Y .joins)
  products .p‚ÇÅ {X} {Y} .bwd‚ä£fwd {x , y} {x'} .proj‚ÇÇ = proj‚ÇÅ
  products .p‚ÇÇ .fwd = meet-semilattice.project‚ÇÇ
  products .p‚ÇÇ .bwd = join-semilattice.inject‚ÇÇ
  products .p‚ÇÇ {X} {Y} .bwd‚ä£fwd {x , y} {y'} .proj‚ÇÅ y'‚â§y .proj‚ÇÅ = X.‚â§-bottom
    where module X = JoinSemilattice (X .joins)
  products .p‚ÇÇ {X} {Y} .bwd‚ä£fwd {x , y} {y'} .proj‚ÇÅ y'‚â§y .proj‚ÇÇ = y'‚â§y
  products .p‚ÇÇ {X} {Y} .bwd‚ä£fwd {x , y} {y'} .proj‚ÇÇ = proj‚ÇÇ
  products .pair f g .fwd = meet-semilattice.‚ü® f .fwd , g .fwd ‚ü©
  products .pair f g .bwd = join-semilattice.[ f .bwd , g .bwd ]
  products .pair {X} {Y} {Z} f g .bwd‚ä£fwd {x} {y , z} .proj‚ÇÅ (y‚â§fx , z‚â§gx) =
    [ f .bwd‚ä£fwd .proj‚ÇÅ y‚â§fx , g .bwd‚ä£fwd .proj‚ÇÅ z‚â§gx ]
    where open IsJoin (X .joins .‚à®-isJoin)
  products .pair {X} {Y} {Z} f g .bwd‚ä£fwd {x} {y , z} .proj‚ÇÇ fy‚à®gz‚â§x =
    f .bwd‚ä£fwd .proj‚ÇÇ (X .‚â§-trans X.inl fy‚à®gz‚â§x) ,
    g .bwd‚ä£fwd .proj‚ÇÇ (X .‚â§-trans X.inr fy‚à®gz‚â§x)
    where module X = JoinSemilattice (X .joins)
  products .pair-cong f‚ÇÅ‚âàf‚ÇÇ g‚ÇÅ‚âàg‚ÇÇ .fwd-eq = meet-semilattice.‚ü®‚ü©-cong (f‚ÇÅ‚âàf‚ÇÇ .fwd-eq) (g‚ÇÅ‚âàg‚ÇÇ .fwd-eq)
  products .pair-cong f‚ÇÅ‚âàf‚ÇÇ g‚ÇÅ‚âàg‚ÇÇ .bwd-eq = join-semilattice.[]-cong (f‚ÇÅ‚âàf‚ÇÇ .bwd-eq) (g‚ÇÅ‚âàg‚ÇÇ .bwd-eq)
  products .pair-p‚ÇÅ f g .fwd-eq = meet-semilattice.pair-p‚ÇÅ (f .fwd) (g .fwd)
  products .pair-p‚ÇÅ f g .bwd-eq = join-semilattice.inj‚ÇÅ-copair (f .bwd) (g .bwd)
  products .pair-p‚ÇÇ f g .fwd-eq = meet-semilattice.pair-p‚ÇÇ (f .fwd) (g .fwd)
  products .pair-p‚ÇÇ f g .bwd-eq = join-semilattice.inj‚ÇÇ-copair (f .bwd) (g .bwd)
  products .pair-ext f .fwd-eq = meet-semilattice.pair-ext (f .fwd)
  products .pair-ext f .bwd-eq = join-semilattice.copair-ext (f .bwd)

{-
-- This category has a lifting monad
module _ where

  ùïÉ : Obj ‚Üí Obj
  ùïÉ X .carrier = L (X .carrier)
  ùïÉ X .meets = meet-semilattice.L (X .meets)
  ùïÉ X .joins = join-semilattice.L (X .joins)

  ùïÉ-map : ‚àÄ {X Y} ‚Üí X ‚áíg Y ‚Üí ùïÉ X ‚áíg ùïÉ Y
  ùïÉ-map f .fwd = meet-semilattice.L-map (f .fwd)
  ùïÉ-map f .bwd = join-semilattice.L-map (f .bwd)
  ùïÉ-map f .bwd‚ä£fwd {bottom} {bottom} .proj‚ÇÅ y‚â§Lfx = tt
  ùïÉ-map f .bwd‚ä£fwd {< x >} {bottom} .proj‚ÇÅ y‚â§Lfx = tt
  ùïÉ-map f .bwd‚ä£fwd {< x >} {< y >} .proj‚ÇÅ y‚â§Lfx = f .bwd‚ä£fwd .proj‚ÇÅ y‚â§Lfx
  ùïÉ-map f .bwd‚ä£fwd {bottom} {bottom} .proj‚ÇÇ Lfy‚â§x = tt
  ùïÉ-map f .bwd‚ä£fwd {< x >} {bottom} .proj‚ÇÇ Lfy‚â§x = tt
  ùïÉ-map f .bwd‚ä£fwd {< x >} {< y >} .proj‚ÇÇ Lfy‚â§x = f .bwd‚ä£fwd .proj‚ÇÇ Lfy‚â§x

  ùïÉ-unit : ‚àÄ {X} ‚Üí X ‚áíg ùïÉ X
  ùïÉ-unit .fwd = meet-semilattice.L-unit
  ùïÉ-unit .bwd = join-semilattice.L-counit
  ùïÉ-unit {X} .bwd‚ä£fwd {x} {bottom} .proj‚ÇÅ tt =
    X .joins .JoinSemilattice.‚ä•-isBottom .IsBottom.‚â§-bottom
  ùïÉ-unit .bwd‚ä£fwd {x} {< x‚ÇÅ >} .proj‚ÇÅ x‚ÇÅ‚â§x = x‚ÇÅ‚â§x
  ùïÉ-unit .bwd‚ä£fwd {x} {bottom} .proj‚ÇÇ x‚ÇÅ = tt
  ùïÉ-unit .bwd‚ä£fwd {x} {< x‚ÇÅ >} .proj‚ÇÇ x‚ÇÅ‚â§x = x‚ÇÅ‚â§x

  ùïÉ-join : ‚àÄ {X} ‚Üí ùïÉ (ùïÉ X) ‚áíg ùïÉ X
  ùïÉ-join .fwd = meet-semilattice.L-join
  ùïÉ-join .bwd = join-semilattice.L-dup
  ùïÉ-join .bwd‚ä£fwd {bottom} {bottom} .proj‚ÇÅ e = tt
  ùïÉ-join .bwd‚ä£fwd {< bottom >} {bottom} .proj‚ÇÅ e = tt
  ùïÉ-join .bwd‚ä£fwd {< < x > >} {bottom} .proj‚ÇÅ e = tt
  ùïÉ-join .bwd‚ä£fwd {< < x > >} {< x‚ÇÅ >} .proj‚ÇÅ e = e
  ùïÉ-join .bwd‚ä£fwd {bottom} {bottom} .proj‚ÇÇ e = tt
  ùïÉ-join .bwd‚ä£fwd {< bottom >} {bottom} .proj‚ÇÇ e = tt
  ùïÉ-join .bwd‚ä£fwd {< < x > >} {bottom} .proj‚ÇÇ e = tt
  ùïÉ-join .bwd‚ä£fwd {< < x > >} {< x‚ÇÅ >} .proj‚ÇÇ e = e

  ùïÉ-strength : ‚àÄ {X Y} ‚Üí (X ‚äó ùïÉ Y) ‚áíg ùïÉ (X ‚äó Y)
  ùïÉ-strength .fwd = meet-semilattice.L-strength
  ùïÉ-strength .bwd = join-semilattice.L-costrength
  ùïÉ-strength {X} {Y} .bwd‚ä£fwd {x , bottom} {bottom} .proj‚ÇÅ e =
    X .joins .JoinSemilattice.‚ä•-isBottom .IsBottom.‚â§-bottom , tt
  ùïÉ-strength {X} {Y} .bwd‚ä£fwd {x , < x‚ÇÅ >} {bottom} .proj‚ÇÅ e =
    X .joins .JoinSemilattice.‚ä•-isBottom .IsBottom.‚â§-bottom , tt
  ùïÉ-strength {X} {Y} .bwd‚ä£fwd {x , < x‚ÇÇ >} {< x‚ÇÅ >} .proj‚ÇÅ e = e
  ùïÉ-strength {X} {Y} .bwd‚ä£fwd {x , bottom} {bottom} .proj‚ÇÇ e = tt
  ùïÉ-strength {X} {Y} .bwd‚ä£fwd {x , < x‚ÇÅ >} {bottom} .proj‚ÇÇ e = tt
  ùïÉ-strength {X} {Y} .bwd‚ä£fwd {x , < x‚ÇÅ >} {< x‚ÇÇ >} .proj‚ÇÇ e = e
-}

module _ where

  open import two using (Two; I; O)

  TWO : Obj
  TWO .carrier .Preorder.Carrier = Two
  TWO .carrier .Preorder._‚â§_ = two._‚â§_
  TWO .carrier .Preorder.‚â§-isPreorder = two.‚â§-isPreorder
  TWO .meets .MeetSemilattice._‚àß_ = two._‚äì_
  TWO .meets .MeetSemilattice.‚ä§ = I
  TWO .meets .MeetSemilattice.‚àß-isMeet = two.‚äì-isMeet
  TWO .meets .MeetSemilattice.‚ä§-isTop .IsTop.‚â§-top = two.I-top
  TWO .joins .JoinSemilattice._‚à®_ = two._‚äî_
  TWO .joins .JoinSemilattice.‚ä• = O
  TWO .joins .JoinSemilattice.‚à®-isJoin = two.‚äî-isJoin
  TWO .joins .JoinSemilattice.‚ä•-isBottom .IsBottom.‚â§-bottom {x} = two.O-bot {x}

  open HasProducts products

  -- This is a monoid because every object in this category is a
  -- monoid by cmon-enrichment. FIXME: actually prove this gives a
  -- monoid.

  conjunct : (TWO ‚äó TWO) ‚áíg TWO
  conjunct = p‚ÇÅ +m p‚ÇÇ

  unit : ùüô ‚áíg TWO
  unit = Œµm
