{-# OPTIONS --prop --postfix-projections --safe #-}

open import Level using (suc; _‚äî_; 0‚Ñì)
open import basics
  using (IsPreorder; IsTop; IsMeet; IsResidual; monoidOfMeet; module ‚â§-Reasoning; IsJoin; IsClosureOp; IsBigJoin)
open import categories using (Category; HasProducts; HasExponentials)

module predicate-system {o m e} (ùíû : Category o m e) (P : HasProducts ùíû) where

private
  module ùíû = Category ùíû
  module P = HasProducts P

record PredicateSystem : Set (suc (suc (o ‚äî m ‚äî e))) where
  field
    Predicate : ùíû.obj ‚Üí Set (suc o ‚äî suc m ‚äî suc e)
    _‚äë_   : ‚àÄ {X : ùíû.obj} ‚Üí Predicate X ‚Üí Predicate X ‚Üí Prop (o ‚äî m ‚äî e)
    ‚äë-isPreorder : ‚àÄ {X} ‚Üí IsPreorder (_‚äë_ {X})

  infix 2 _‚äë_

  ‚äë-trans : ‚àÄ {X} {P Q R : Predicate X} ‚Üí P ‚äë Q ‚Üí Q ‚äë R ‚Üí P ‚äë R
  ‚äë-trans = ‚äë-isPreorder .IsPreorder.trans

  field
    _[_]   : ‚àÄ {X Y} ‚Üí Predicate Y ‚Üí X ùíû.‚áí Y ‚Üí Predicate X
    _‚ü®_‚ü©   : ‚àÄ {X Y} ‚Üí Predicate X ‚Üí X ùíû.‚áí Y ‚Üí Predicate Y

    _[_]m     : ‚àÄ {X Y} {P Q : Predicate Y} ‚Üí P ‚äë Q ‚Üí (f : X ùíû.‚áí Y) ‚Üí (P [ f ]) ‚äë (Q [ f ])
    []-cong   : ‚àÄ {X Y} {P : Predicate Y}{f‚ÇÅ f‚ÇÇ : X ùíû.‚áí Y} ‚Üí f‚ÇÅ ùíû.‚âà f‚ÇÇ ‚Üí (P [ f‚ÇÅ ]) ‚äë (P [ f‚ÇÇ ])
    []-id     : ‚àÄ {X} {P : Predicate X} ‚Üí P ‚äë (P [ ùíû.id _ ])
    []-id‚Åª¬π   : ‚àÄ {X} {P : Predicate X} ‚Üí (P [ ùíû.id _ ]) ‚äë P
    []-comp   : ‚àÄ {X Y Z} {P : Predicate Z} (f : Y ùíû.‚áí Z) (g : X ùíû.‚áí Y) ‚Üí ((P [ f ]) [ g ]) ‚äë (P [ f ùíû.‚àò g ])
    []-comp‚Åª¬π : ‚àÄ {X Y Z} {P : Predicate Z} (f : Y ùíû.‚áí Z) (g : X ùíû.‚áí Y) ‚Üí (P [ f ùíû.‚àò g ]) ‚äë ((P [ f ]) [ g ])

    adjoint‚ÇÅ : ‚àÄ {X Y} {P : Predicate X} {Q : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí P ‚ü® f ‚ü© ‚äë Q ‚Üí P ‚äë Q [ f ]
    adjoint‚ÇÇ : ‚àÄ {X Y} {P : Predicate X} {Q : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí P ‚äë Q [ f ] ‚Üí P ‚ü® f ‚ü© ‚äë Q

  unit : ‚àÄ {X Y} {P : Predicate X} (f : X ùíû.‚áí Y) ‚Üí P ‚äë P ‚ü® f ‚ü© [ f ]
  unit f = adjoint‚ÇÅ (IsPreorder.refl ‚äë-isPreorder)

  counit : ‚àÄ {X Y} {P : Predicate Y} (f : X ùíû.‚áí Y) ‚Üí P [ f ] ‚ü® f ‚ü© ‚äë P
  counit f = adjoint‚ÇÇ (IsPreorder.refl ‚äë-isPreorder)

  _‚ü®_‚ü©m : ‚àÄ {X Y} {P Q : Predicate X} ‚Üí P ‚äë Q ‚Üí (f : X ùíû.‚áí Y) ‚Üí (P ‚ü® f ‚ü©) ‚äë (Q ‚ü® f ‚ü©)
  P‚äëQ ‚ü® f ‚ü©m = adjoint‚ÇÇ (IsPreorder.trans ‚äë-isPreorder P‚äëQ (unit f))

  ‚ü®‚ü©-comp : ‚àÄ {X Y Z} {P : Predicate X} (f : Y ùíû.‚áí Z) (g : X ùíû.‚áí Y) ‚Üí (P ‚ü® g ‚ü© ‚ü® f ‚ü©) ‚äë (P ‚ü® f ùíû.‚àò g ‚ü©)
  ‚ü®‚ü©-comp f g = adjoint‚ÇÇ (adjoint‚ÇÇ (‚äë-trans (unit _) ([]-comp‚Åª¬π f g)))

  ‚ü®‚ü©-cong : ‚àÄ {X Y} {P : Predicate X}{f‚ÇÅ f‚ÇÇ : X ùíû.‚áí Y} ‚Üí f‚ÇÅ ùíû.‚âà f‚ÇÇ ‚Üí (P ‚ü® f‚ÇÅ ‚ü©) ‚äë (P ‚ü® f‚ÇÇ ‚ü©)
  ‚ü®‚ü©-cong f‚ÇÅ‚âàf‚ÇÇ = adjoint‚ÇÇ (‚äë-trans (unit _) ([]-cong (ùíû.‚âà-sym f‚ÇÅ‚âàf‚ÇÇ)))

  field
    TT    : ‚àÄ {X} ‚Üí Predicate X
    _&&_  : ‚àÄ {X} ‚Üí Predicate X ‚Üí Predicate X ‚Üí Predicate X
    _++_  : ‚àÄ {X} ‚Üí Predicate X ‚Üí Predicate X ‚Üí Predicate X
    _==>_ : ‚àÄ {X} ‚Üí Predicate X ‚Üí Predicate X ‚Üí Predicate X
    ‚ãÄ     : ‚àÄ {X Y} ‚Üí Predicate (P.prod X Y) ‚Üí Predicate X

    TT-isTop  : ‚àÄ {X} ‚Üí IsTop ‚äë-isPreorder (TT {X})
    []-TT     : ‚àÄ {X Y} {f : X ùíû.‚áí Y} ‚Üí TT ‚äë TT [ f ]

    &&-isMeet : ‚àÄ {X} ‚Üí IsMeet ‚äë-isPreorder (_&&_ {X})
    []-&&     : ‚àÄ {X Y} {P Q : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí ((P [ f ]) && (Q [ f ])) ‚äë ((P && Q) [ f ])

    ++-isJoin : ‚àÄ {X} ‚Üí IsJoin ‚äë-isPreorder (_++_ {X})
    []-++     : ‚àÄ {X Y} {P Q : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí ((P ++ Q) [ f ]) ‚äë ((P [ f ]) ++ (Q [ f ]))

    ==>-residual : ‚àÄ {X} ‚Üí IsResidual ‚äë-isPreorder (monoidOfMeet _ &&-isMeet TT-isTop) (_==>_ {X})
    []-==> : ‚àÄ {X Y}{P Q : Predicate Y}{f : X ùíû.‚áí Y} ‚Üí ((P [ f ]) ==> (Q [ f ])) ‚äë (P ==> Q) [ f ]

    ‚ãÄ-[] : ‚àÄ {X X' Y} {P : Predicate (P.prod X Y)} {f : X' ùíû.‚áí X} ‚Üí (‚ãÄ (P [ P.prod-m f (ùíû.id _) ])) ‚äë (‚ãÄ P) [ f ]
    ‚ãÄ-eval : ‚àÄ {X Y} {P : Predicate (P.prod X Y)} ‚Üí ((‚ãÄ P) [ P.p‚ÇÅ ]) ‚äë P
    ‚ãÄ-lambda : ‚àÄ {X Y} {P : Predicate X} {Q : Predicate (P.prod X Y)} ‚Üí P [ P.p‚ÇÅ ] ‚äë Q ‚Üí P ‚äë ‚ãÄ Q

    -- FIXME: this is experimental
    ‚ãÅ        : ‚àÄ {X} (I : Set 0‚Ñì) ‚Üí (I ‚Üí Predicate X) ‚Üí Predicate X
    ‚ãÅ-isJoin : ‚àÄ {X} ‚Üí IsBigJoin (‚äë-isPreorder {X}) 0‚Ñì ‚ãÅ
    []-‚ãÅ     : ‚àÄ {X Y I} {P : I ‚Üí Predicate Y} {f : X ùíû.‚áí Y} ‚Üí (‚ãÅ I P [ f ]) ‚äë ‚ãÅ I (Œª i ‚Üí P i [ f ])

  -- Derived properties of meets
  _[&&]_ : ‚àÄ {X Y} ‚Üí Predicate X ‚Üí Predicate Y ‚Üí Predicate (P.prod X Y)
  P [&&] Q = (P [ P.p‚ÇÅ ]) && (Q [ P.p‚ÇÇ ])

  [&&]-p‚ÇÅ : ‚àÄ {X Y}{P : Predicate X}{Q : Predicate Y} ‚Üí (P [&&] Q) ‚äë P [ P.p‚ÇÅ ]
  [&&]-p‚ÇÅ = &&-isMeet .IsMeet.œÄ‚ÇÅ

  [&&]-p‚ÇÇ : ‚àÄ {X Y}{P : Predicate X}{Q : Predicate Y} ‚Üí (P [&&] Q) ‚äë Q [ P.p‚ÇÇ ]
  [&&]-p‚ÇÇ = &&-isMeet .IsMeet.œÄ‚ÇÇ

  [&&]-pair : ‚àÄ {X Y Z}{P : Predicate X}{Q : Predicate Y}{R : Predicate Z}
              {f : X ùíû.‚áí Y} {g : X ùíû.‚áí Z} ‚Üí
              P ‚äë Q [ f ] ‚Üí
              P ‚äë R [ g ] ‚Üí
              P ‚äë (Q [&&] R) [ P.pair f g ]
  [&&]-pair {X} {Y} {Z} {P} {Q} {R} {f} {g} œï œà = begin
      P
    ‚â§‚ü® &&-isMeet .IsMeet.‚ü®_,_‚ü© œï œà ‚ü©
      (Q [ f ]) && (R [ g ])
    ‚â§‚ü® IsMeet.mono &&-isMeet ([]-cong (ùíû.‚âà-sym (P.pair-p‚ÇÅ f g))) ([]-cong (ùíû.‚âà-sym (P.pair-p‚ÇÇ f g))) ‚ü©
      (Q [ P.p‚ÇÅ ùíû.‚àò P.pair f g ]) && (R [ P.p‚ÇÇ ùíû.‚àò P.pair f g  ])
    ‚â§‚ü® IsMeet.mono &&-isMeet ([]-comp‚Åª¬π _ _) ([]-comp‚Åª¬π _ _) ‚ü©
      (Q [ P.p‚ÇÅ ] [ P.pair f g ]) && (R [ P.p‚ÇÇ ]  [ P.pair f g  ])
    ‚â§‚ü® []-&& ‚ü©
      (Q [&&] R) [ P.pair f g ]
    ‚àé
    where open ‚â§-Reasoning ‚äë-isPreorder

  --
  []-++‚Åª¬π : ‚àÄ {X Y} {P Q : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí ((P [ f ]) ++ (Q [ f ])) ‚äë ((P ++ Q) [ f ])
  []-++‚Åª¬π = ++-isJoin .IsJoin.[_,_] ((++-isJoin .IsJoin.inl) [ _ ]m) ((++-isJoin .IsJoin.inr) [ _ ]m)

  -- Derived properties of products
  ‚ãÄ-[]‚Åª¬π : ‚àÄ {X X' Y} {P : Predicate (P.prod X Y)} {f : X' ùíû.‚áí X} ‚Üí (‚ãÄ P) [ f ] ‚äë (‚ãÄ (P [ P.prod-m f (ùíû.id _) ]))
  ‚ãÄ-[]‚Åª¬π {X} {X'} {Y} {P} {f} = ‚ãÄ-lambda Œ¶
    where
      Œ¶ : ((‚ãÄ P [ f ]) [ P.p‚ÇÅ ]) ‚äë (P [ P.prod-m f (ùíû.id Y) ])
      Œ¶ = begin
            (‚ãÄ P [ f ]) [ P.p‚ÇÅ ]
           ‚â§‚ü® []-comp _ _ ‚ü©
            ‚ãÄ P [ f ùíû.‚àò P.p‚ÇÅ ]
           ‚â§‚ü® []-cong (ùíû.‚âà-sym (P.pair-p‚ÇÅ _ _)) ‚ü©
            ‚ãÄ P [ P.p‚ÇÅ ùíû.‚àò P.prod-m f (ùíû.id Y) ]
           ‚â§‚ü® []-comp‚Åª¬π _ _ ‚ü©
            ‚ãÄ P [ P.p‚ÇÅ ] [ P.prod-m f (ùíû.id Y) ]
           ‚â§‚ü® ‚ãÄ-eval [ _ ]m ‚ü©
            P [ P.prod-m f (ùíû.id Y) ]
       ‚àé
       where open ‚â§-Reasoning ‚äë-isPreorder

record ClosureOp (S : PredicateSystem) : Set (suc (o ‚äî m ‚äî e)) where
  open PredicateSystem S
  field
    ùêÇ           : ‚àÄ {X} ‚Üí Predicate X ‚Üí Predicate X
    ùêÇ-isClosure : ‚àÄ {X} ‚Üí IsClosureOp (‚äë-isPreorder {X}) ùêÇ
    ùêÇ-[]        : ‚àÄ {X Y} {P : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí ùêÇ (P [ f ]) ‚äë (ùêÇ P [ f ])
    ùêÇ-[]‚Åª¬π      : ‚àÄ {X Y} {P : Predicate Y} {f : X ùíû.‚áí Y} ‚Üí (ùêÇ P [ f ]) ‚äë ùêÇ (P [ f ])
    ùêÇ-strong    : ‚àÄ {X} {P Q : Predicate X} ‚Üí (ùêÇ P && Q) ‚äë ùêÇ (P && Q)

  ùêÇ-monoidal : ‚àÄ {X} {P Q : Predicate X} ‚Üí (ùêÇ P && ùêÇ Q) ‚äë ùêÇ (P && Q)
  ùêÇ-monoidal {X} {P} {Q} = begin
      ùêÇ P && ùêÇ Q
    ‚â§‚ü® ùêÇ-strong ‚ü©
      ùêÇ (P && ùêÇ Q)
    ‚â§‚ü® ùêÇ-isClosure .IsClosureOp.mono (IsMeet.comm &&-isMeet) ‚ü©
      ùêÇ (ùêÇ Q && P)
    ‚â§‚ü® ùêÇ-isClosure .IsClosureOp.mono ùêÇ-strong ‚ü©
      ùêÇ (ùêÇ (Q && P))
    ‚â§‚ü® ùêÇ-isClosure .IsClosureOp.closed ‚ü©
      ùêÇ (Q && P)
    ‚â§‚ü® ùêÇ-isClosure .IsClosureOp.mono (IsMeet.comm &&-isMeet) ‚ü©
      ùêÇ (P && Q)
    ‚àé
    where open ‚â§-Reasoning ‚äë-isPreorder

module exponentials (S : PredicateSystem) (E : HasExponentials ùíû P) where

  open PredicateSystem S
  private
    module E = HasExponentials E

  _[=>]_ : ‚àÄ {X Y} ‚Üí Predicate X ‚Üí Predicate Y ‚Üí Predicate (E.exp X Y)
  P [=>] Q = ‚ãÄ ((P [ P.p‚ÇÇ ]) ==> (Q [ E.eval ]))

  [=>]-lambda : ‚àÄ {X Y Z} {P : Predicate X} {Q : Predicate Y} {R : Predicate Z} {f : P.prod X Y ùíû.‚áí Z} ‚Üí
                (P [&&] Q) ‚äë R [ f ] ‚Üí P ‚äë (Q [=>] R) [ E.lambda f ]
  [=>]-lambda {X} {Y} {Z} {P} {Q} {R} {f} œï = begin
      P
    ‚â§‚ü® ‚ãÄ-lambda Œ® ‚ü©
      ‚ãÄ (((Q [ P.p‚ÇÇ ]) ==> (R [ E.eval ])) [ P.prod-m (E.lambda f) (ùíû.id _) ])
    ‚â§‚ü® ‚ãÄ-[] ‚ü©
      ((Q [=>] R) [ E.lambda f ])
    ‚àé
    where
      Œ® : (P [ P.p‚ÇÅ ]) ‚äë (((Q [ P.p‚ÇÇ ]) ==> (R [ E.eval ])) [ P.prod-m (E.lambda f) (ùíû.id Y) ])
      Œ® = begin
            P [ P.p‚ÇÅ ]
          ‚â§‚ü® ==>-residual .IsResidual.lambda œï ‚ü©
            (Q [ P.p‚ÇÇ ]) ==> (R [ f ])
          ‚â§‚ü® IsResidual.-‚àô-mono ==>-residual ([]-cong ùíû.id-left) (‚äë-isPreorder .IsPreorder.refl) ‚ü©
            (Q [ ùíû.id Y ùíû.‚àò P.p‚ÇÇ ]) ==> (R [ f ])
          ‚â§‚ü® IsResidual.-‚àô-mono ==>-residual ([]-cong (P.pair-p‚ÇÇ _ _)) ([]-cong (ùíû.‚âà-sym (E.eval-lambda _))) ‚ü©
            (Q [ P.p‚ÇÇ ùíû.‚àò P.prod-m (E.lambda f) (ùíû.id Y) ]) ==> (R [ E.eval ùíû.‚àò P.prod-m (E.lambda f) (ùíû.id Y) ])
          ‚â§‚ü® IsResidual.-‚àô-mono ==>-residual ([]-comp _ _) ([]-comp‚Åª¬π _ _) ‚ü©
            (Q [ P.p‚ÇÇ ] [ P.prod-m (E.lambda f) (ùíû.id Y) ]) ==> (R [ E.eval ] [ P.prod-m (E.lambda f) (ùíû.id Y) ])
          ‚â§‚ü® []-==> ‚ü©
            ((Q [ P.p‚ÇÇ ]) ==> (R [ E.eval ])) [ P.prod-m (E.lambda f) (ùíû.id Y) ]
          ‚àé
          where open ‚â§-Reasoning ‚äë-isPreorder

      open ‚â§-Reasoning ‚äë-isPreorder

  [=>]-eval : ‚àÄ {X Y} {P : Predicate X} {Q : Predicate Y} ‚Üí
              ((P [=>] Q) [&&] P) ‚äë Q [ E.eval ]
  [=>]-eval {X} {Y} {P} {Q} = begin
      (‚ãÄ ((P [ P.p‚ÇÇ ]) ==> (Q [ E.eval ])) [ P.p‚ÇÅ ]) && (P [ P.p‚ÇÇ ])
    ‚â§‚ü® IsMeet.mono &&-isMeet ‚ãÄ-eval (‚äë-isPreorder .IsPreorder.refl) ‚ü©
      ((P [ P.p‚ÇÇ ]) ==> (Q [ E.eval ])) && (P [ P.p‚ÇÇ ])
    ‚â§‚ü® ==>-residual .IsResidual.eval ‚ü©
      Q [ E.eval ]
    ‚àé
    where open ‚â§-Reasoning ‚äë-isPreorder

  [=>]-mono : ‚àÄ {X Y} {P P' : Predicate X} {Q Q' : Predicate Y} ‚Üí
              P' ‚äë P ‚Üí
              Q ‚äë Q' ‚Üí
              (P [=>] Q) ‚äë (P' [=>] Q')
  [=>]-mono {X} {Y} {P} {P'} {Q} {Q'} œï œà = ‚ãÄ-lambda (==>-residual .IsResidual.lambda (begin
      (‚ãÄ ((P [ P.p‚ÇÇ ]) ==> (Q [ E.eval ])) [ P.p‚ÇÅ ]) && (P' [ P.p‚ÇÇ ])
    ‚â§‚ü® IsMeet.mono &&-isMeet ‚ãÄ-eval (œï [ _ ]m) ‚ü©
      ((P [ P.p‚ÇÇ ]) ==> (Q [ E.eval ])) && (P [ P.p‚ÇÇ ])
    ‚â§‚ü® ==>-residual .IsResidual.eval ‚ü©
      Q [ E.eval ]
    ‚â§‚ü® œà [ _ ]m ‚ü©
      Q' [ E.eval ]
    ‚àé))
    where open ‚â§-Reasoning ‚äë-isPreorder

--   [=>]-reindex :
