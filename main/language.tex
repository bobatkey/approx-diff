\section{Higher-Order Language}
\label{sec:language}

To model Galois slicing semantically for higher-order programs, we define a simple total functional
programming language over a signature of base types and primitive operations, extending the simply-typed
lambda calculus.

\subsection{Syntax}
\label{sec:language:syntax}

The language is parameterised by a signature $\Sigma = (\PrimTy, \PrimOp)$ consisting of a set $\PrimTy$ of
base types $\rho$ and a family of sets $\PrimOp^\rho_{\rho_1,\ldots,\rho_n}$ of primitive operations $\phi$ of
arity $n$ over those base types. The syntax is defined in \figref{syntax}. Types includes base types $\rho$
drawn from $\PrimTy$, along with standard type formers for sums, products, functions and lists, plus a type
constructor $\tyLift$ to allow approximation points to be added explicitly, as discussed in
\secref{models-of-total-gps}. Terms include variables, the usual introduction and elimination forms, a monadic
return and bind for lifted terms, and primitive operations $\phi$.

The language is intentionally minimal: it excludes general recursion, and general inductive or coinductive
types, which we will consider in future work (\secref{conclusion}). Typing judgments for terms are standard
and shown in \figref{typing}, with the usual rules for products, sums, functions, lists and lifting.

\input{fig/syntax}
\input{fig/typing}

\subsection{Semantics}
\label{sec:language:semantics}

\input{fig/semantics}

A model $M$ of $\Sigma$ can be given in any category $\cat{C}$ with finite products and a terminal object, and
assigns to each base type $\rho \in \PrimTy$ an object $\sem{\rho}_{M}$ in $\cat{C}$, and to each primitive
operation $\phi \in \PrimOp^\rho_{\rho_1,\ldots,\rho_n}$, a morphism $\sem{\phi}_{M}: \sem{\rho_1}_{M} \times
\ldots \times \sem{\rho_n}_{M} \to \sem{\rho}_{M}$. A model of $\tyList$ can also be given in $\cat{C}$ and
consists of an endofunctor $\List: \cat{C} \to \cat{C}$, plus for any object $X$, morphisms $\nil: 1 \to
\List(X)$ and $\cons: X \times \List(X) \to \List(X)$, and for any objects $Y, Z$ and morphisms $f_\nil: Z \to
Y$ and $f_\cons: Z \times X \times Y \to Y$, a morphism $\fold(f_\nil,f_\cons): Z \times \List(X) \to Y$.

To give the semantics for the full language, we fix a bicartesian closed category $\Sem$ with a strong monad
$(\Lift, \eta, \mu)$ with strength $\mathsf{st}$, a model $M$ of $\Sigma$ in $\Sem$, and a model of $\tyList$
in $\Sem$.

\figref{semantics:types} gives the interpretations of types $\tau$ and contexts $\Gamma$ as objects of $\Sem$.
\figref{semantics:terms} gives the interpretation of terms $\Gamma \vdash t: \tau$ as morphisms $\sem{\Gamma}
\to \sem{\tau}$.

\subsubsection{Interpretation for higher-order \GPS}

\paragraph{Base types and operations}
Given an interpretation of base types and operations in $\Fam(\LatGal)$, the category $\Fam(\MeetSLat \times
\JoinSLat^\op)$ can implement $\Sem$. It is bicartesian closed (\corref{mslat-jslat-bcc}) and can model
$\List(X)$ as an infinite coproduct (\secref{models-of-total-gps:coproducts-and-products}). An interpretation
of base types and operations can be obtained from their interpretation in $\Fam(\LatGal)$ via the embedding
...
\roly{$\Lift$ monad.}
