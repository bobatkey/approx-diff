\section{Higher-Order Language}
\label{sec:language}

To model Galois slicing semantically for higher-order programs, we define a simple total functional
programming language, extending the simply-typed lambda calculus.

\subsection{Syntax}
\label{sec:language:syntax}

The language includes base types $\rho$ drawn from a set $\PrimTy$, along with standard type formers for sums,
products, functions and lists, and an additional lifting type constructor $\tyLift$ to allow approximation
points to be added explicitly, as discussed in \secref{models-of-total-gps}. Terms include variables, the
usual introduction and elimination forms, a monadic return and bind for lifted terms, and primitive operations
$\phi$ of arity $n$ drawn from a family of sets $\PrimOp^\rho_{\rho_1,\ldots,\rho_n}$.

The language is intentionally minimal: it excludes general recursion, and general inductive or coinductive
types, which will consider in future work (\secref{conclusion}). Typing judgments for terms are standard and
shown in \figref{typing}, with the usual rules for products, sums, functions, lists and lifting.

\input{fig/syntax}
\input{fig/typing}

\subsection{Semantics}
\label{sec:language:semantics}

\input{fig/semantics}

To give the semantics for the language defined in \figrefTwo{syntax}{typing}, we fix a bicartesian closed
category $\Sem$ with finite products $(\times, 1)$, finite coproducts $(+, 0)$ and exponentials
$\internalHom{X}{Y}$, with evaluation morphisms $\eval_{X,Y}$ and currying isomorphisms $\lambda_{X,Y,Z}$,
plus the following additional structure:
\begin{enumerate}
\item a strong monad $(\Lift, \eta, \mu)$ with strength $\mathsf{st}_{X,Y}: X \times \Lift(Y) \to \Lift(X
\times Y)$
\item for each base type $\rho \in \PrimTy$, an object $\sem{\rho}_{\PrimTy}$
\item for each primitive operation $\phi \in \PrimOp^\rho_{\rho_1,\ldots,\rho_n}$, a morphism $\sem{\phi}:
\sem{\rho_1} \times \ldots \times \sem{\rho_n} \to \sem{\rho}$
\item an endofunctor $\List: \Sem \to \Sem$, plus for any object $X$, morphisms $\nil: 1 \to \List(X)$ and
$\cons: X \times \List(X) \to \List(X)$, and for any objects $Y, Z$ and morphisms $f_\nil: Z \to Y$ and
$f_\cons: Z \times X \times Y \to Y$, a morphism $\fold(f_\nil,f_\cons): Z \times \List(X) \to Y$.
\end{enumerate}

\figref{semantics:types} gives the interpretations of types $\tau$ and contexts $\Gamma$ as objects of $\Sem$.
\figref{semantics:terms} gives the interpretation of terms $\Gamma \vdash t: \tau$ as morphisms $\sem{\Gamma}
\to \sem{\tau}$.

\subsubsection{Interpretation for higher-order \GPS}

$\Fam(\MeetSLat \times \JoinSLat^\op)$ meets the requirements of $\Sem$: it is bicartesian closed
(\corref{mslat-jslat-bcc}), can model $\List(X)$ as an infinite coproduct
(\secref{models-of-total-gps:coproducts-and-products}), \roly{$\Lift$ monad, base types and operations.}
